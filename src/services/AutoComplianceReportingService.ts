// Auto Compliance Reporting Service for emergency deletions
import { ReportCategory, ReportSubmissionForm } from '../types/whistleblowing';
import { HierarchicalUser } from '../types';
import { ContentModerationService } from './ContentModerationService';
import { NotificationService } from './NotificationService';
import { v4 as uuidv4 } from 'uuid';

// Auto-generated compliance report
interface AutoComplianceReport {
  id: string;
  deletionId: string;
  category: ReportCategory;
  title: string;
  content: string;
  evidence: string;
  deletedBy: string;
  deletedAt: Date;
  autoGenerated: boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  followUpRequired: string[];
  notificationsSent: string[];
  reviewStatus: 'pending' | 'under_review' | 'resolved';
  assignedTo?: string;
}

// Compliance escalation rule
interface EscalationRule {
  violationType: string;
  severity: string;
  targetLevel: number;
  escalationDelay: number; // hours
  requiredActions: string[];
}

export class AutoComplianceReportingService {
  private static instance: AutoComplianceReportingService;
  private autoReports: Map<string, AutoComplianceReport> = new Map();
  private notificationService: NotificationService;

  // Escalation rules for different violation types
  private readonly ESCALATION_RULES: EscalationRule[] = [
    {
      violationType: 'harassment',
      severity: 'critical',
      targetLevel: 8, // HR General Manager
      escalationDelay: 1,
      requiredActions: ['即座面談実施', 'ハラスメント調査開始', '被害者保護措置']
    },
    {
      violationType: 'harassment',
      severity: 'high',
      targetLevel: 7, // HR Dept Head
      escalationDelay: 2,
      requiredActions: ['面談実施', 'ハラスメント予備調査']
    },
    {
      violationType: 'personal_attack',
      severity: 'critical',
      targetLevel: 7,
      escalationDelay: 2,
      requiredActions: ['関係者面談', '職場環境調査']
    },
    {
      violationType: 'privacy_violation',
      severity: 'critical',
      targetLevel: 8,
      escalationDelay: 0.5, // 30 minutes
      requiredActions: ['情報漏洩調査', 'セキュリティ対策確認', '法務相談']
    },
    {
      violationType: 'legal_risk',
      severity: 'high',
      targetLevel: 9, // Director level
      escalationDelay: 1,
      requiredActions: ['法務部門相談', 'リスク評価実施']
    },
    {
      violationType: 'organizational_risk',
      severity: 'critical',
      targetLevel: 10, // Executive level
      escalationDelay: 0.25, // 15 minutes
      requiredActions: ['危機管理対応', '広報部門連絡', '役員緊急会議']
    }
  ];

  private constructor() {
    this.notificationService = NotificationService.getInstance();
    this.startEscalationMonitor();
  }

  static getInstance(): AutoComplianceReportingService {
    if (!AutoComplianceReportingService.instance) {
      AutoComplianceReportingService.instance = new AutoComplianceReportingService();
    }
    return AutoComplianceReportingService.instance;
  }

  // Generate automatic compliance report from emergency deletion
  public async generateAutoReport(
    deletionId: string,
    postContent: string,
    postTitle: string | undefined,
    deletedBy: HierarchicalUser,
    deletionReason: string,
    violations: any[]
  ): Promise<string> {
    
    // Determine report category and severity
    const { category, severity } = this.analyzeViolations(violations);
    
    // Generate report content
    const reportId = uuidv4();
    const report: AutoComplianceReport = {
      id: reportId,
      deletionId,
      category,
      title: this.generateReportTitle(category, severity),
      content: this.generateReportContent(postContent, postTitle, deletionReason, violations),
      evidence: this.generateEvidenceSection(deletionId, violations),
      deletedBy: deletedBy.id,
      deletedAt: new Date(),
      autoGenerated: true,
      severity,
      followUpRequired: this.generateFollowUpActions(violations),
      notificationsSent: [],
      reviewStatus: 'pending'
    };

    // Store the report
    this.autoReports.set(reportId, report);

    // Send immediate notifications
    await this.sendImmediateNotifications(report, deletedBy);

    // Schedule escalations if needed
    this.scheduleEscalations(report, violations);

    console.log(`自動コンプライアンス通報生成完了:`, {
      reportId,
      category: report.category,
      severity: report.severity,
      deletedBy: deletedBy.name
    });

    return reportId;
  }

  // Analyze violations to determine category and severity
  private analyzeViolations(violations: any[]): { category: ReportCategory; severity: 'low' | 'medium' | 'high' | 'critical' } {
    if (violations.length === 0) {
      return { category: 'other', severity: 'low' };
    }

    // Find the most severe violation
    let highestSeverity: 'low' | 'medium' | 'high' | 'critical' = 'low';
    let primaryCategory: ReportCategory = 'other';

    for (const violation of violations) {
      // Update severity
      if (this.compareSeverity(violation.severity, highestSeverity) > 0) {
        highestSeverity = violation.severity;
      }

      // Determine category based on violation type
      switch (violation.violationType) {
        case 'harassment':
        case 'personal_attack':
          primaryCategory = 'harassment';
          break;
        case 'privacy_violation':
          primaryCategory = 'compliance';
          break;
        case 'legal_risk':
          primaryCategory = 'compliance';
          break;
        case 'organizational_risk':
          primaryCategory = 'other';
          break;
      }
    }

    return { category: primaryCategory, severity: highestSeverity };
  }

  // Compare severity levels
  private compareSeverity(a: string, b: string): number {
    const levels = { 'low': 1, 'medium': 2, 'high': 3, 'critical': 4 };
    return (levels[a as keyof typeof levels] || 0) - (levels[b as keyof typeof levels] || 0);
  }

  // Generate report title
  private generateReportTitle(category: ReportCategory, severity: string): string {
    const severityText = {
      'low': '軽微',
      'medium': '中程度',
      'high': '重大',
      'critical': '緊急'
    }[severity] || '不明';

    const categoryText = {
      'harassment': 'ハラスメント',
      'safety': '安全管理',
      'financial': '財務',
      'compliance': 'コンプライアンス',
      'discrimination': '差別・不公正',
      'other': 'その他'
    }[category] || 'その他';

    return `【自動通報】${severityText}な${categoryText}問題の緊急削除`;
  }

  // Generate detailed report content
  private generateReportContent(
    postContent: string,
    postTitle: string | undefined,
    deletionReason: string,
    violations: any[]
  ): string {
    let content = `## 自動コンプライアンス通報\n\n`;
    content += `**通報種別**: 緊急投稿削除に伴う自動通報\n`;
    content += `**発生日時**: ${new Date().toLocaleString('ja-JP')}\n`;
    content += `**システム判定**: 自動検出による緊急削除\n\n`;

    content += `### 削除された投稿内容\n`;
    if (postTitle) {
      content += `**タイトル**: ${postTitle}\n`;
    }
    content += `**本文**: ${postContent.substring(0, 500)}${postContent.length > 500 ? '...' : ''}\n\n`;

    content += `### 削除理由\n${deletionReason}\n\n`;

    if (violations.length > 0) {
      content += `### 検出された違反内容\n`;
      violations.forEach((violation, index) => {
        content += `${index + 1}. **${this.getViolationTypeText(violation.violationType)}** (${violation.severity})\n`;
        content += `   - ${violation.description}\n`;
        if (violation.matchedPhrases && violation.matchedPhrases.length > 0) {
          content += `   - 検出語句: ${violation.matchedPhrases.join(', ')}\n`;
        }
        content += `\n`;
      });
    }

    content += `### 必要な対応\n`;
    content += `1. 削除の妥当性確認\n`;
    content += `2. 関係者への聞き取り調査\n`;
    content += `3. 再発防止策の検討\n`;
    content += `4. 必要に応じた懲戒処分の検討\n\n`;

    content += `**注意**: この通報は投稿削除システムによって自動生成されました。\n`;
    content += `詳細な調査と適切な対応をお願いいたします。`;

    return content;
  }

  // Generate evidence section
  private generateEvidenceSection(deletionId: string, violations: any[]): string {
    let evidence = `削除ID: ${deletionId}\n`;
    evidence += `削除タイムスタンプ: ${new Date().toISOString()}\n`;
    evidence += `システム検出ログ: ${violations.length}件の違反を検出\n\n`;

    evidence += `検出詳細:\n`;
    violations.forEach((violation, index) => {
      evidence += `${index + 1}. ${violation.violationType} (${violation.severity})\n`;
      evidence += `   検出パターン: ${violation.matchedPhrases?.join(', ') || 'システム判定'}\n`;
    });

    return evidence;
  }

  // Generate follow-up actions
  private generateFollowUpActions(violations: any[]): string[] {
    const actions = new Set<string>();

    violations.forEach(violation => {
      switch (violation.violationType) {
        case 'harassment':
          actions.add('ハラスメント調査委員会の設置');
          actions.add('被害者・加害者面談の実施');
          actions.add('職場環境改善策の検討');
          break;
        case 'personal_attack':
          actions.add('当事者面談の実施');
          actions.add('職場環境調査');
          break;
        case 'privacy_violation':
          actions.add('個人情報漏洩調査');
          actions.add('情報セキュリティ対策の見直し');
          actions.add('該当者への注意喚起');
          break;
        case 'legal_risk':
          actions.add('法務部門への相談');
          actions.add('法的リスク評価');
          actions.add('予防策の策定');
          break;
        case 'organizational_risk':
          actions.add('広報部門への報告');
          actions.add('危機管理対応の検討');
          actions.add('ステークホルダーへの対応');
          break;
      }
    });

    // Always add general follow-up actions
    actions.add('削除妥当性の事後確認');
    actions.add('再発防止策の検討');

    return Array.from(actions);
  }

  // Get violation type text in Japanese
  private getViolationTypeText(violationType: string): string {
    const types: Record<string, string> = {
      'harassment': 'ハラスメント',
      'personal_attack': '個人攻撃',
      'privacy_violation': '個人情報漏洩',
      'legal_risk': '法的リスク',
      'organizational_risk': '組織リスク',
      'inappropriate_language': '不適切な表現',
      'spam': 'スパム'
    };
    return types[violationType] || '不明な違反';
  }

  // Send immediate notifications
  private async sendImmediateNotifications(report: AutoComplianceReport, deletedBy: HierarchicalUser): Promise<void> {
    const notifications: string[] = [];

    // Notify HR department (Level 7+)
    await this.notificationService.sendNotification({
      recipientLevel: 7,
      type: 'emergency_deletion',
      title: '緊急投稿削除通知',
      message: `${deletedBy.name}により投稿が緊急削除され、自動コンプライアンス通報が生成されました。`,
      actionRequired: true,
      relatedResourceId: report.id,
      relatedResourceType: 'compliance_report'
    });
    notifications.push('HR部門への通知完了');

    // Notify compliance team
    await this.notificationService.sendNotification({
      recipientLevel: 8,
      type: 'compliance_alert',
      title: '自動コンプライアンス通報',
      message: `重要度: ${report.severity} | カテゴリ: ${report.category}`,
      actionRequired: true,
      relatedResourceId: report.id,
      relatedResourceType: 'compliance_report'
    });
    notifications.push('コンプライアンスチームへの通知完了');

    // For critical violations, notify executives immediately
    if (report.severity === 'critical') {
      await this.notificationService.sendNotification({
        recipientLevel: 9,
        type: 'critical_alert',
        title: '緊急コンプライアンス事案',
        message: `重大な違反により投稿が緊急削除されました。即座の対応が必要です。`,
        actionRequired: true,
        relatedResourceId: report.id,
        relatedResourceType: 'compliance_report'
      });
      notifications.push('役員レベルへの緊急通知完了');
    }

    // Update notification record
    report.notificationsSent = notifications;
    console.log('緊急通知送信完了:', notifications);
  }

  // Schedule escalations based on violation severity
  private scheduleEscalations(report: AutoComplianceReport, violations: any[]): void {
    violations.forEach(violation => {
      const rule = this.ESCALATION_RULES.find(r => 
        r.violationType === violation.violationType && 
        r.severity === violation.severity
      );

      if (rule) {
        setTimeout(() => {
          this.executeEscalation(report, rule);
        }, rule.escalationDelay * 60 * 60 * 1000); // Convert hours to milliseconds
      }
    });
  }

  // Execute escalation
  private async executeEscalation(report: AutoComplianceReport, rule: EscalationRule): Promise<void> {
    // Check if report is still pending
    if (report.reviewStatus !== 'pending') {
      return;
    }

    console.log(`エスカレーション実行:`, {
      reportId: report.id,
      violationType: rule.violationType,
      targetLevel: rule.targetLevel,
      requiredActions: rule.requiredActions
    });

    // Send escalation notification
    await this.notificationService.sendNotification({
      recipientLevel: rule.targetLevel,
      type: 'escalation_alert',
      title: 'コンプライアンス事案エスカレーション',
      message: `対応期限を超過したため、自動エスカレーションが実行されました。`,
      actionRequired: true,
      relatedResourceId: report.id,
      relatedResourceType: 'compliance_report',
      deadline: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
    });

    // Update follow-up actions
    report.followUpRequired = [...report.followUpRequired, ...rule.requiredActions];
    
    // Assign to appropriate authority level
    report.assignedTo = `LEVEL_${rule.targetLevel}`;
  }

  // Start escalation monitoring
  private startEscalationMonitor(): void {
    setInterval(() => {
      this.checkOverdueReports();
    }, 30 * 60 * 1000); // Check every 30 minutes
  }

  // Check for overdue reports
  private checkOverdueReports(): void {
    const now = new Date();
    const overdueThreshold = 72 * 60 * 60 * 1000; // 72 hours

    this.autoReports.forEach((report, reportId) => {
      if (report.reviewStatus === 'pending') {
        const timeSinceDeletion = now.getTime() - report.deletedAt.getTime();
        
        if (timeSinceDeletion > overdueThreshold) {
          console.log(`期限超過レポート検出:`, {
            reportId,
            hoursSinceDeletion: timeSinceDeletion / (60 * 60 * 1000),
            severity: report.severity
          });

          // Auto-escalate to executive level
          this.notificationService.sendNotification({
            recipientLevel: 10,
            type: 'overdue_alert',
            title: 'コンプライアンス対応期限超過',
            message: `緊急削除案件の対応が72時間を超過しています。`,
            actionRequired: true,
            relatedResourceId: reportId,
            relatedResourceType: 'compliance_report'
          });
        }
      }
    });
  }

  // Update report status
  public updateReportStatus(reportId: string, status: 'pending' | 'under_review' | 'resolved', assignedTo?: string): boolean {
    const report = this.autoReports.get(reportId);
    if (!report) {
      return false;
    }

    report.reviewStatus = status;
    if (assignedTo) {
      report.assignedTo = assignedTo;
    }

    console.log(`レポート状況更新:`, { reportId, status, assignedTo });
    return true;
  }

  // Get all auto-generated reports
  public getAutoReports(filters?: {
    severity?: string;
    category?: ReportCategory;
    status?: string;
    startDate?: Date;
    endDate?: Date;
  }): AutoComplianceReport[] {
    let reports = Array.from(this.autoReports.values());

    if (filters) {
      if (filters.severity) {
        reports = reports.filter(r => r.severity === filters.severity);
      }
      if (filters.category) {
        reports = reports.filter(r => r.category === filters.category);
      }
      if (filters.status) {
        reports = reports.filter(r => r.reviewStatus === filters.status);
      }
      if (filters.startDate) {
        reports = reports.filter(r => r.deletedAt >= filters.startDate!);
      }
      if (filters.endDate) {
        reports = reports.filter(r => r.deletedAt <= filters.endDate!);
      }
    }

    return reports.sort((a, b) => b.deletedAt.getTime() - a.deletedAt.getTime());
  }

  // Get compliance statistics
  public getComplianceStats(): {
    totalReports: number;
    byCategory: Record<ReportCategory, number>;
    bySeverity: Record<string, number>;
    byStatus: Record<string, number>;
    avgResponseTime: number;
    overdueReports: number;
  } {
    const reports = Array.from(this.autoReports.values());
    const now = new Date();

    const byCategory: Record<ReportCategory, number> = {
      harassment: 0,
      safety: 0,
      financial: 0,
      compliance: 0,
      discrimination: 0,
      other: 0
    };

    const bySeverity: Record<string, number> = {
      low: 0,
      medium: 0,
      high: 0,
      critical: 0
    };

    const byStatus: Record<string, number> = {
      pending: 0,
      under_review: 0,
      resolved: 0
    };

    let totalResponseTime = 0;
    let resolvedCount = 0;
    let overdueCount = 0;

    reports.forEach(report => {
      byCategory[report.category]++;
      bySeverity[report.severity]++;
      byStatus[report.reviewStatus]++;

      if (report.reviewStatus === 'resolved') {
        resolvedCount++;
        // In production, calculate actual response time
      }

      // Check if overdue (72 hours for pending reports)
      if (report.reviewStatus === 'pending') {
        const hoursSince = (now.getTime() - report.deletedAt.getTime()) / (60 * 60 * 1000);
        if (hoursSince > 72) {
          overdueCount++;
        }
      }
    });

    return {
      totalReports: reports.length,
      byCategory,
      bySeverity,
      byStatus,
      avgResponseTime: resolvedCount > 0 ? totalResponseTime / resolvedCount : 0,
      overdueReports: overdueCount
    };
  }
}