# コンプライアンス通報 Webhook認証仕様書（HMAC-SHA256）

**発信**: 医療システムチーム
**宛先**: VoiceDriveチーム
**日時**: 2025年10月3日
**件名**: Webhook認証方式の詳細仕様
**重要度**: 🔴 **必須実装**

---

## 📋 概要

医療システムからVoiceDriveへ送信するコンプライアンス通報受付確認通知のWebhook認証方式について、HMAC-SHA256を使用した署名検証の詳細を説明します。

---

## 🔐 認証方式: HMAC-SHA256

### なぜHMAC-SHA256を使用するのか

1. **改ざん検知**: メッセージの内容が改ざんされていないことを保証
2. **送信元認証**: 正当な送信元（医療システム）からのリクエストであることを検証
3. **リプレイ攻撃対策**: タイムスタンプと組み合わせることで古いリクエストを拒否
4. **業界標準**: GitHub、Stripe、Slackなど多くのサービスで採用

---

## 🔧 実装詳細

### 1. 共有シークレットキー

**環境変数**:
```bash
# 医療システム側
VOICEDRIVE_WEBHOOK_SECRET=your-secret-key-here-min-32-chars

# VoiceDrive側
MEDICAL_SYSTEM_WEBHOOK_SECRET=your-secret-key-here-min-32-chars
```

**キー要件**:
- 最低32文字以上
- ランダムな文字列（英数字 + 記号）
- 本番環境とテスト環境で異なるキーを使用
- 定期的なローテーション（推奨: 90日ごと）

**キー生成例**:
```bash
# OpenSSLで生成
openssl rand -hex 32

# Node.jsで生成
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# 出力例
# a7f3c9e1b2d8f4a6c9e7b3f1d4a8c2e6f9b7d3a1c5e8f2b6d9a4c7e1f3b8d2a6
```

---

### 2. 署名生成（医療システム側）

#### 2.1 TypeScript/Node.js実装

```typescript
import crypto from 'crypto';

// 署名生成関数
function generateWebhookSignature(payload: any, secret: string): string {
  const payloadString = JSON.stringify(payload);

  return crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');
}

// 使用例
const notificationData = {
  reportId: "VD-2025-1234",
  caseNumber: "MED-2025-0001",
  anonymousId: "ANON-5678",
  // ... その他のフィールド
};

const secret = process.env.VOICEDRIVE_WEBHOOK_SECRET;
const signature = generateWebhookSignature(notificationData, secret);

// HTTPリクエスト送信
await fetch('https://voicedrive.example.com/api/webhook/compliance/acknowledgement', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Webhook-Signature': signature,
    'X-Webhook-Timestamp': new Date().toISOString(),
    'X-Case-Number': notificationData.caseNumber,
    'X-Anonymous-Id': notificationData.anonymousId,
  },
  body: JSON.stringify(notificationData)
});
```

#### 2.2 ステップ詳細

```typescript
// ステップ1: ペイロードをJSON文字列に変換
const payloadString = JSON.stringify(payload);
// 例: '{"reportId":"VD-2025-1234","caseNumber":"MED-2025-0001",...}'

// ステップ2: HMAC-SHA256オブジェクト作成
const hmac = crypto.createHmac('sha256', secret);

// ステップ3: データを更新
hmac.update(payloadString);

// ステップ4: 16進数文字列として署名を取得
const signature = hmac.digest('hex');
// 例: 'a3f7c9e1b2d8f4a6c9e7b3f1d4a8c2e6f9b7d3a1c5e8f2b6d9a4c7e1f3b8d2a6'
```

---

### 3. 署名検証（VoiceDrive側）

#### 3.1 TypeScript/Node.js実装

```typescript
import crypto from 'crypto';

// 署名検証関数
function verifyWebhookSignature(
  receivedSignature: string,
  payload: any,
  secret: string
): boolean {
  // 受信したペイロードから期待される署名を生成
  const payloadString = JSON.stringify(payload);
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');

  // タイミング攻撃を防ぐため、crypto.timingSafeEqualを使用
  try {
    const receivedBuffer = Buffer.from(receivedSignature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    return crypto.timingSafeEqual(receivedBuffer, expectedBuffer);
  } catch (error) {
    // 長さが異なる場合などはfalseを返す
    return false;
  }
}

// Expressでの使用例
app.post('/api/webhook/compliance/acknowledgement', (req, res) => {
  const receivedSignature = req.headers['x-webhook-signature'] as string;
  const secret = process.env.MEDICAL_SYSTEM_WEBHOOK_SECRET;

  // 署名検証
  if (!verifyWebhookSignature(receivedSignature, req.body, secret)) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_SIGNATURE',
        message: 'Webhook signature verification failed'
      }
    });
  }

  // タイムスタンプ検証（オプションだが推奨）
  const timestamp = req.headers['x-webhook-timestamp'] as string;
  if (!verifyTimestamp(timestamp)) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'TIMESTAMP_EXPIRED',
        message: 'Webhook timestamp is too old'
      }
    });
  }

  // 正常処理
  // ... データベース保存、通知送信など

  res.status(200).json({
    success: true,
    notificationId: 'NOTIF-12345',
    receivedAt: new Date().toISOString()
  });
});

// タイムスタンプ検証関数（リプレイ攻撃対策）
function verifyTimestamp(timestamp: string, maxAgeMinutes: number = 5): boolean {
  try {
    const receivedTime = new Date(timestamp).getTime();
    const currentTime = Date.now();
    const ageMinutes = (currentTime - receivedTime) / 1000 / 60;

    // 5分以上古いリクエストは拒否
    return ageMinutes <= maxAgeMinutes;
  } catch (error) {
    return false;
  }
}
```

#### 3.2 検証フロー

```
1. リクエスト受信
   ↓
2. X-Webhook-Signature ヘッダーを取得
   ↓
3. リクエストボディ（JSON）から期待される署名を計算
   ↓
4. 受信した署名と計算した署名を比較（crypto.timingSafeEqual使用）
   ↓
5a. 一致 → タイムスタンプ検証へ
5b. 不一致 → 401 Unauthorized返却
   ↓
6. X-Webhook-Timestamp が5分以内か確認
   ↓
7a. 5分以内 → 正常処理
7b. 5分超過 → 401 Unauthorized返却
```

---

## 📨 HTTPヘッダー仕様

### 医療システムからVoiceDriveへのリクエスト

```http
POST /api/webhook/compliance/acknowledgement HTTP/1.1
Host: voicedrive.example.com
Content-Type: application/json
X-Webhook-Signature: a3f7c9e1b2d8f4a6c9e7b3f1d4a8c2e6f9b7d3a1c5e8f2b6d9a4c7e1f3b8d2a6
X-Webhook-Timestamp: 2025-10-03T10:30:00.000Z
X-Case-Number: MED-2025-0001
X-Anonymous-Id: ANON-5678
X-Request-Id: req-uuid-12345

{
  "reportId": "VD-2025-1234",
  "caseNumber": "MED-2025-0001",
  "anonymousId": "ANON-5678",
  ...
}
```

### ヘッダー詳細

| ヘッダー | 必須 | 説明 | 例 |
|---------|------|------|-----|
| `Content-Type` | ✅ | リクエストボディの形式 | `application/json` |
| `X-Webhook-Signature` | ✅ | HMAC-SHA256署名（16進数） | `a3f7c9e1...` |
| `X-Webhook-Timestamp` | ✅ | リクエスト生成日時（ISO 8601） | `2025-10-03T10:30:00.000Z` |
| `X-Case-Number` | ✅ | 医療システムケース番号 | `MED-2025-0001` |
| `X-Anonymous-Id` | ✅ | 匿名ID | `ANON-5678` |
| `X-Request-Id` | 推奨 | リクエスト追跡用UUID | `req-uuid-12345` |

---

## 🧪 テストケース

### テストケース1: 正常な署名検証

**シナリオ**: 正しい署名とペイロードが送信される

```typescript
// テストデータ
const testPayload = {
  reportId: "VD-TEST-001",
  caseNumber: "MED-2025-0001",
  anonymousId: "ANON-TEST-001",
  severity: "high",
  category: "ハラスメント",
  receivedAt: "2025-10-03T10:00:00.000Z",
  estimatedResponseTime: "当日中"
};

const testSecret = "test-secret-key-for-development-use-only-32chars";

// 署名生成
const signature = crypto
  .createHmac('sha256', testSecret)
  .update(JSON.stringify(testPayload))
  .digest('hex');

// 期待結果
// - 署名検証: ✅ 成功
// - HTTPステータス: 200 OK
// - レスポンス: { success: true, ... }
```

### テストケース2: 不正な署名

**シナリオ**: 誤った署名が送信される

```typescript
const testPayload = { /* 同上 */ };
const wrongSignature = "0000000000000000000000000000000000000000000000000000000000000000";

// 期待結果
// - 署名検証: ❌ 失敗
// - HTTPステータス: 401 Unauthorized
// - レスポンス: { success: false, error: { code: "INVALID_SIGNATURE", ... } }
```

### テストケース3: ペイロード改ざん検知

**シナリオ**: 署名は正しいが、ペイロードが改ざんされている

```typescript
const originalPayload = {
  reportId: "VD-TEST-001",
  caseNumber: "MED-2025-0001",
  severity: "medium"
};

// 正しい署名を生成
const validSignature = generateWebhookSignature(originalPayload, testSecret);

// ペイロードを改ざん
const tamperedPayload = {
  ...originalPayload,
  severity: "critical" // 改ざん
};

// 期待結果
// - 署名検証: ❌ 失敗（ペイロードが変更されているため）
// - HTTPステータス: 401 Unauthorized
```

### テストケース4: 古いタイムスタンプ（リプレイ攻撃）

**シナリオ**: 6分前のタイムスタンプを持つリクエスト

```typescript
const testPayload = { /* 同上 */ };
const validSignature = generateWebhookSignature(testPayload, testSecret);
const oldTimestamp = new Date(Date.now() - 6 * 60 * 1000).toISOString(); // 6分前

// 期待結果
// - 署名検証: ✅ 成功
// - タイムスタンプ検証: ❌ 失敗（5分超過）
// - HTTPステータス: 401 Unauthorized
// - レスポンス: { success: false, error: { code: "TIMESTAMP_EXPIRED", ... } }
```

### テストケース5: 未来のタイムスタンプ

**シナリオ**: 未来の時刻を持つタイムスタンプ

```typescript
const futureTimestamp = new Date(Date.now() + 10 * 60 * 1000).toISOString(); // 10分後

// 期待結果
// - タイムスタンプ検証: ❌ 失敗
// - HTTPステータス: 401 Unauthorized
```

---

## 🔒 セキュリティベストプラクティス

### 1. タイミング攻撃対策

**問題**: 単純な文字列比較（`signature1 === signature2`）は、タイミング攻撃に脆弱

**対策**: `crypto.timingSafeEqual()` を使用

```typescript
// ❌ 脆弱なコード
if (receivedSignature === expectedSignature) {
  // 処理
}

// ✅ 安全なコード
const receivedBuffer = Buffer.from(receivedSignature, 'hex');
const expectedBuffer = Buffer.from(expectedSignature, 'hex');

if (crypto.timingSafeEqual(receivedBuffer, expectedBuffer)) {
  // 処理
}
```

### 2. シークレットキーの管理

**DO**:
- ✅ 環境変数で管理
- ✅ 定期的にローテーション（90日推奨）
- ✅ 本番とテストで異なるキーを使用
- ✅ 最低32文字以上のランダムな文字列

**DON'T**:
- ❌ ハードコード
- ❌ GitHubなどにコミット
- ❌ 短いキー（< 32文字）
- ❌ 予測可能な文字列（"password"など）

### 3. リプレイ攻撃対策

**実装**:
```typescript
function verifyTimestamp(timestamp: string): boolean {
  const receivedTime = new Date(timestamp).getTime();
  const currentTime = Date.now();
  const ageMinutes = Math.abs(currentTime - receivedTime) / 1000 / 60;

  // 前後5分以内のみ許可
  return ageMinutes <= 5;
}
```

### 4. ログ記録

**記録すべき情報**:
```typescript
// 成功時
logger.info('Webhook received', {
  requestId: req.headers['x-request-id'],
  caseNumber: req.headers['x-case-number'],
  anonymousId: req.headers['x-anonymous-id'],
  timestamp: req.headers['x-webhook-timestamp'],
  signatureValid: true
});

// 失敗時
logger.warn('Webhook signature verification failed', {
  requestId: req.headers['x-request-id'],
  ipAddress: req.ip,
  timestamp: req.headers['x-webhook-timestamp'],
  reason: 'INVALID_SIGNATURE'
});
```

**記録してはいけない情報**:
- ❌ シークレットキー
- ❌ 完全なペイロード（個人情報が含まれる場合）
- ❌ 署名の完全な値（ハッシュ化したものなら可）

---

## 🛠️ トラブルシューティング

### エラー1: 署名検証が常に失敗する

**原因**:
1. シークレットキーの不一致
2. ペイロードのJSON文字列化の順序が異なる
3. 文字エンコーディングの問題

**解決方法**:
```typescript
// デバッグ用: 両システムで同じペイロードとキーで署名を生成し、比較
const payload = { test: "data" };
const secret = "test-secret";

// 医療システム側
const medicalSignature = crypto.createHmac('sha256', secret)
  .update(JSON.stringify(payload))
  .digest('hex');
console.log('Medical System Signature:', medicalSignature);

// VoiceDrive側
const voicedriveSignature = crypto.createHmac('sha256', secret)
  .update(JSON.stringify(payload))
  .digest('hex');
console.log('VoiceDrive Signature:', voicedriveSignature);

// 両者が一致すれば、実装は正しい
```

### エラー2: タイムスタンプ検証が失敗する

**原因**:
- システムクロックのずれ
- タイムゾーンの問題

**解決方法**:
```typescript
// 両システムの現在時刻を確認
console.log('Current Time:', new Date().toISOString());

// タイムスタンプの許容範囲を広げる（開発環境のみ）
const maxAgeMinutes = process.env.NODE_ENV === 'production' ? 5 : 15;
```

---

## 📦 実装チェックリスト

### 医療システム側
- [x] 署名生成関数の実装
- [x] Webhookリクエスト送信処理
- [x] エラーハンドリング・リトライ機構
- [x] 監査ログ記録

### VoiceDrive側
- [ ] 署名検証関数の実装
- [ ] タイムスタンプ検証の実装
- [ ] Webhookエンドポイントの作成
- [ ] エラーレスポンスの実装
- [ ] 監査ログ記録

---

## 🔗 参考リンク

### 公式ドキュメント
- [Node.js Crypto HMAC](https://nodejs.org/api/crypto.html#crypto_class_hmac)
- [MDN: HMAC](https://developer.mozilla.org/en-US/docs/Glossary/HMAC)

### 実例
- [GitHub Webhooks](https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks)
- [Stripe Webhooks](https://stripe.com/docs/webhooks/signatures)
- [Slack Webhooks](https://api.slack.com/authentication/verifying-requests-from-slack)

---

## 📞 サポート

技術的な質問やWebhook実装に関する相談は、mcp-shared/フォルダ経由でご連絡ください。

---

**作成日時**: 2025年10月3日
**作成者**: 医療システムチーム
**バージョン**: 1.0

---

*本仕様書は、セキュアなWebhook通信を実現するための技術ガイドです。*
