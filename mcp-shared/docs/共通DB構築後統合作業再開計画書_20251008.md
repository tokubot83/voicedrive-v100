# å…±é€šDBæ§‹ç¯‰å¾Œçµ±åˆä½œæ¥­å†é–‹è¨ˆç”»æ›¸

**æ–‡æ›¸ç•ªå·**: INT-PLAN-2025-1008-001
**ä½œæˆæ—¥**: 2025å¹´10æœˆ8æ—¥
**ä½œæˆè€…**: VoiceDriveãƒãƒ¼ãƒ 
**ç›®çš„**: MySQL DBæ§‹ç¯‰å®Œäº†å¾Œã€VoiceDriveã¨åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆä½œæ¥­ã‚’å††æ»‘ã«å†é–‹ã™ã‚‹ãŸã‚ã®è¨ˆç”»æ›¸
**é‡è¦åº¦**: ğŸ”´ æœ€é‡è¦
**å‰ææ–‡æ›¸**: [ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»åˆ†ç•Œç‚¹å®šç¾©æ›¸_20251008.md](./ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»åˆ†ç•Œç‚¹å®šç¾©æ›¸_20251008.md)

---

## ğŸ“‹ ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

### ç¾åœ¨ã®çŠ¶æ³ï¼ˆ2025å¹´10æœˆ10æ—¥æ™‚ç‚¹ï¼‰

#### âœ… å®Œäº†ã—ãŸä½œæ¥­
1. **ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»åˆ†ç•Œç‚¹å®šç¾©æ›¸ã®ä½œæˆ**ï¼ˆ2025å¹´10æœˆ8æ—¥ï¼‰
   - VoiceDriveã¨åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ é–“ã®ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»ã‚’æ˜ç¢ºåŒ–
   - 10ã‚«ãƒ†ã‚´ãƒªã€60é …ç›®ä»¥ä¸Šã®ãƒ‡ãƒ¼ã‚¿é …ç›®ã‚’åˆ†æ
   - API/Webhooké€£æºæ–¹å¼ã‚’å®šç¾©

2. **VoiceDrive MySQLç§»è¡Œæº–å‚™å®Œäº†**ï¼ˆ2025å¹´10æœˆ8æ—¥ï¼‰
   - `validateEnv.ts` ä½œæˆï¼ˆç’°å¢ƒå¤‰æ•°ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
   - `prisma/schema.prisma` ã‚’MySQLå¯¾å¿œã«å¤‰æ›´
   - `MySQL_Migration_Guide.md` ä½œæˆï¼ˆ292è¡Œï¼‰
   - `.env`, `.env.production` ã‚’MySQLæ¥ç¶šæ–‡å­—åˆ—ã«æ›´æ–°
   - Git commits: 74fb6cc, f9db560, 0b17d07, 3be6b51, a89ac48

3. **åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ DBæ§‹ç¯‰è¨ˆç”»æ›¸ã®åˆ†æ**ï¼ˆ2025å¹´10æœˆ8æ—¥ï¼‰
   - å…¨12,118è¡Œã€29ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€146ãƒ†ãƒ¼ãƒ–ãƒ«ã®æ§‹ç¯‰è¨ˆç”»ã‚’å®Œå…¨åˆ†æ
   - VoiceDriveã¨ã®é‡è¤‡ãƒ»é€£æºãƒã‚¤ãƒ³ãƒˆã‚’ç‰¹å®š

4. **PersonalStationãƒšãƒ¼ã‚¸ã®DBè¦ä»¶åˆ†æå®Œäº†**ï¼ˆ2025å¹´10æœˆ8-9æ—¥ï¼‰
   - [PersonalStation_DBè¦ä»¶åˆ†æ_20251008.md](./PersonalStation_DBè¦ä»¶åˆ†æ_20251008.md) ä½œæˆ
   - [PersonalStationæš«å®šãƒã‚¹ã‚¿ãƒ¼ãƒªã‚¹ãƒˆ_20251008.md](./PersonalStationæš«å®šãƒã‚¹ã‚¿ãƒ¼ãƒªã‚¹ãƒˆ_20251008.md) ä½œæˆ
   - åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã¸ã®APIä¾é ¼2ä»¶ã€Webhookä¾é ¼4ä»¶ã‚’æ˜ç¢ºåŒ–
   - æ¨å®šå·¥æ•°: åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´2æ—¥ã€VoiceDriveå´5-8æ—¥

5. **OrganizationAnalyticsãƒšãƒ¼ã‚¸ã®DBè¦ä»¶åˆ†æå®Œäº†**ï¼ˆ2025å¹´10æœˆ10æ—¥ï¼‰ğŸ†•
   - [organization-analytics_DBè¦ä»¶åˆ†æ_20251010.md](./organization-analytics_DBè¦ä»¶åˆ†æ_20251010.md) ä½œæˆ
   - [organization-analyticsæš«å®šãƒã‚¹ã‚¿ãƒ¼ãƒªã‚¹ãƒˆ_20251010.md](./organization-analyticsæš«å®šãƒã‚¹ã‚¿ãƒ¼ãƒªã‚¹ãƒˆ_20251010.md) ä½œæˆ
   - [OrganizationAnalytics_åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ é€£æºè¦ä»¶ç¢ºèªæ›¸_20251010.md](./OrganizationAnalytics_åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ é€£æºè¦ä»¶ç¢ºèªæ›¸_20251010.md) ä½œæˆ
   - åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã¸ã®APIä¾é ¼2ä»¶ã€ç¢ºèªäº‹é …2ä»¶ã‚’æ˜ç¢ºåŒ–
   - schema.prismaæ›´æ–°ï¼ˆManagementCommitteeAgendaã«å®Ÿè£…è¿½è·¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ ï¼‰
   - æ¨å®šå·¥æ•°: åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´2.5æ—¥ã€VoiceDriveå´3.5æ—¥

#### â³ ä¿ç•™ä¸­ã®ä½œæ¥­ï¼ˆDBæ§‹ç¯‰å¾…ã¡ï¼‰
1. **MySQLç’°å¢ƒæ§‹ç¯‰**ï¼ˆåŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´ï¼‰
   - AWS Lightsailçµ±åˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ§‹ç¯‰
   - MySQL 8.0ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   - åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ DBä½œæˆ

2. **VoiceDrive MySQLç§»è¡Œå®Ÿè¡Œ**
   - `prisma migrate deploy`
   - ãƒ‡ãƒ¼ã‚¿ç§»è¡Œãƒãƒƒãƒå®Ÿè¡Œ
   - å‹•ä½œç¢ºèª

3. **çµ±åˆä½œæ¥­**ï¼ˆæœ¬è¨ˆç”»æ›¸ã®å¯¾è±¡ï¼‰
   - APIå®Ÿè£…
   - Webhookå®Ÿè£…
   - çµ±åˆãƒ†ã‚¹ãƒˆ

---

## ğŸ¯ DBæ§‹ç¯‰å®Œäº†å¾Œã®ä½œæ¥­ãƒ•ãƒ­ãƒ¼

### Phase 1: ç’°å¢ƒç¢ºèªãƒ»æº–å‚™ï¼ˆ1æ—¥ï¼‰

#### 1-1. MySQLç’°å¢ƒç¢ºèª
```bash
# åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´ã§å®Ÿè¡Œ
mysql -u root -p -e "SELECT VERSION();"
mysql -u root -p -e "SHOW DATABASES;"
mysql -u root -p -e "SELECT User, Host FROM mysql.user;"

# VoiceDriveå´ã§å®Ÿè¡Œ
cd /c/projects/voicedrive-v100
npm run db:test-connection
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] MySQL 8.0ãŒæ­£å¸¸ã«èµ·å‹•ã—ã¦ã„ã‚‹
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ DBï¼ˆ`staff_medical_system`ï¼‰ãŒå­˜åœ¨ã™ã‚‹
- [ ] VoiceDriveDBï¼ˆ`voicedrive_prod`ï¼‰ãŒå­˜åœ¨ã™ã‚‹
- [ ] ä¸¡æ–¹ã®DBã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
- [ ] æ–‡å­—ã‚³ãƒ¼ãƒ‰ãŒUTF-8ï¼ˆutf8mb4ï¼‰
- [ ] ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹

#### 1-2. Prismaãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ

**VoiceDriveå´**:
```bash
cd /c/projects/voicedrive-v100

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
npx prisma migrate deploy

# ç¢ºèª
npx prisma db pull
npx prisma generate

# ãƒ†ã‚¹ãƒˆ
npm run test:db
```

**åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´**:
```bash
cd /c/projects/staff-medical-system

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
npx prisma migrate deploy

# ç¢ºèª
npx prisma db pull
npx prisma generate

# ãƒ†ã‚¹ãƒˆ
npm run test:db
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] VoiceDrive: å…¨ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆå®Œäº†ï¼ˆUser, Notification, Interview, Evaluationç­‰ï¼‰
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ : å…¨146ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆå®Œäº†
- [ ] Prisma ClientãŒæ­£å¸¸ã«ç”Ÿæˆã•ã‚Œã‚‹
- [ ] åŸºæœ¬çš„ãªCRUDæ“ä½œãŒå‹•ä½œã™ã‚‹

#### 1-3. ç’°å¢ƒå¤‰æ•°ç¢ºèª

**VoiceDrive `.env`**:
```env
# MySQLæ¥ç¶š
DATABASE_URL="mysql://voicedrive_user:${DB_PASSWORD}@localhost:3306/voicedrive_prod"

# åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ APIæ¥ç¶š
MEDICAL_SYSTEM_API_URL="http://localhost:8080/api"
MEDICAL_SYSTEM_API_KEY="${MEDICAL_API_KEY}"

# Webhookç½²åæ¤œè¨¼
WEBHOOK_SECRET="${WEBHOOK_SECRET}"

# JWT
JWT_SECRET="${JWT_SECRET}"
```

**åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ  `.env`**:
```env
# MySQLæ¥ç¶š
DATABASE_URL="mysql://medical_user:${DB_PASSWORD}@localhost:3306/staff_medical_system"

# VoiceDriveAPIæ¥ç¶š
VOICEDRIVE_API_URL="http://localhost:3001/api"
VOICEDRIVE_API_KEY="${VOICEDRIVE_API_KEY}"

# Webhookç½²åæ¤œè¨¼
WEBHOOK_SECRET="${WEBHOOK_SECRET}"
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] DATABASE_URLãŒæ­£ã—ã„
- [ ] ç›¸äº’ã®API URLãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] Webhookç½²åç”¨ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ï¼ˆåŒä¸€å€¤ï¼‰

---

### Phase 2: åŸºæœ¬APIå®Ÿè£…ï¼ˆ6.5æ—¥ï¼‰ğŸ”„

**æ›´æ–°**: OrganizationAnalyticsç”¨APIã¨ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…ã‚’è¿½åŠ ï¼ˆ+3.5æ—¥ï¼‰
- åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´: éƒ¨é–€ãƒã‚¹ã‚¿ãƒ»è·å“¡ç·æ•°APIï¼ˆ+1æ—¥ï¼‰
- VoiceDriveå´: OrganizationAnalyticsServiceï¼ˆ+2.5æ—¥ï¼‰

#### 2-1. åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´: è·å“¡æƒ…å ±æä¾›API

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/api/routes/employee.routes.ts`

```typescript
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateAPI } from '../middleware/auth';

const router = Router();
const prisma = new PrismaClient();

/**
 * GET /api/employees/:employeeId
 * è·å“¡æƒ…å ±å–å¾—ï¼ˆVoiceDriveç”¨ï¼‰
 */
router.get('/:employeeId', authenticateAPI, async (req, res) => {
  try {
    const { employeeId } = req.params;

    const employee = await prisma.employee.findUnique({
      where: { employeeId },
      select: {
        employeeId: true,
        name: true,
        nameKana: true,
        email: true,
        department: true,
        facility: true,
        position: true,
        permissionLevel: true,
        canPerformLeaderDuty: true,
        professionCategory: true,
        parentId: true,
        hireDate: true,
        yearsOfService: true,
        isActive: true,
        // å€‹äººæƒ…å ±ã¯å«ã‚ãªã„
        // phone: false,
        // birthDate: false,
        // address: false,
      }
    });

    if (!employee) {
      return res.status(404).json({ error: 'Employee not found' });
    }

    // VoiceDriveç”¨ã«å¤‰æ›
    const response = {
      employeeId: employee.employeeId,
      name: employee.name,
      nameKana: employee.nameKana,
      email: employee.email,
      department: employee.department,
      facility: employee.facility,
      position: employee.position,
      permissionLevel: employee.permissionLevel,
      canPerformLeaderDuty: employee.canPerformLeaderDuty,
      professionCategory: employee.professionCategory,
      parentId: employee.parentId,
      hireDate: employee.hireDate,
      yearsOfService: employee.yearsOfService,
      totalExperienceYears: await calculateTotalExperience(employeeId),
      isActive: employee.isActive
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching employee:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/employees
 * è·å“¡ãƒªã‚¹ãƒˆå–å¾—ï¼ˆãƒšãƒ¼ã‚¸ãƒ³ã‚°ï¼‰
 */
router.get('/', authenticateAPI, async (req, res) => {
  try {
    const {
      facility,
      department,
      page = 1,
      limit = 50,
      updatedSince
    } = req.query;

    const skip = (Number(page) - 1) * Number(limit);

    const where: any = { isActive: true };
    if (facility) where.facility = facility;
    if (department) where.department = department;
    if (updatedSince) where.updatedAt = { gte: new Date(updatedSince as string) };

    const [employees, totalCount] = await Promise.all([
      prisma.employee.findMany({
        where,
        select: {
          employeeId: true,
          name: true,
          email: true,
          department: true,
          facility: true,
          position: true,
          permissionLevel: true,
        },
        skip,
        take: Number(limit),
        orderBy: { updatedAt: 'desc' }
      }),
      prisma.employee.count({ where })
    ]);

    res.json({
      employees,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        totalCount,
        totalPages: Math.ceil(totalCount / Number(limit)),
        hasNext: skip + Number(limit) < totalCount
      },
      filters: { facility, department, updatedSince }
    });
  } catch (error) {
    console.error('Error fetching employees:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] GET /api/employees/:employeeId ãŒå‹•ä½œã™ã‚‹
- [ ] GET /api/employeesï¼ˆãƒªã‚¹ãƒˆï¼‰ãŒå‹•ä½œã™ã‚‹
- [ ] èªè¨¼ï¼ˆJWT/APIã‚­ãƒ¼ï¼‰ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] å€‹äººæƒ…å ±ï¼ˆä½æ‰€ãƒ»é›»è©±ç­‰ï¼‰ãŒå«ã¾ã‚Œã¦ã„ãªã„
- [ ] ãƒšãƒ¼ã‚¸ãƒ³ã‚°ãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

#### 2-2. VoiceDriveå´: UseråŒæœŸæ©Ÿèƒ½

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/services/EmployeeSyncService.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import axios from 'axios';

const prisma = new PrismaClient();

interface MedicalSystemEmployee {
  employeeId: string;
  name: string;
  nameKana?: string;
  email: string;
  department?: string;
  facility?: string;
  position?: string;
  permissionLevel: number;
  canPerformLeaderDuty: boolean;
  professionCategory?: string;
  parentId?: string;
  hireDate?: Date;
  yearsOfService?: number;
  totalExperienceYears?: number;
  isActive: boolean;
}

export class EmployeeSyncService {
  private apiUrl = process.env.MEDICAL_SYSTEM_API_URL;
  private apiKey = process.env.MEDICAL_SYSTEM_API_KEY;

  /**
   * åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰è·å“¡æƒ…å ±ã‚’å–å¾—ã—ã¦Userãƒ†ãƒ¼ãƒ–ãƒ«ã«åŒæœŸ
   */
  async syncEmployee(employeeId: string): Promise<void> {
    try {
      // åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ APIã‹ã‚‰å–å¾—
      const response = await axios.get<MedicalSystemEmployee>(
        `${this.apiUrl}/employees/${employeeId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const employee = response.data;

      // VoiceDrive Userãƒ†ãƒ¼ãƒ–ãƒ«ã«åŒæœŸï¼ˆupsertï¼‰
      await prisma.user.upsert({
        where: { employeeId },
        create: {
          employeeId: employee.employeeId,
          email: employee.email,
          name: employee.name,
          department: employee.department,
          facilityId: employee.facility,
          role: employee.position,
          position: employee.position,
          accountType: 'staff',
          permissionLevel: employee.permissionLevel,
          canPerformLeaderDuty: employee.canPerformLeaderDuty,
          professionCategory: employee.professionCategory,
          parentId: employee.parentId,
        },
        update: {
          email: employee.email,
          name: employee.name,
          department: employee.department,
          facilityId: employee.facility,
          role: employee.position,
          position: employee.position,
          permissionLevel: employee.permissionLevel,
          canPerformLeaderDuty: employee.canPerformLeaderDuty,
          professionCategory: employee.professionCategory,
          parentId: employee.parentId,
        }
      });

      console.log(`Employee synced: ${employeeId}`);
    } catch (error) {
      console.error(`Error syncing employee ${employeeId}:`, error);
      throw error;
    }
  }

  /**
   * å…¨è·å“¡ã‚’åŒæœŸï¼ˆåˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”¨ï¼‰
   */
  async syncAllEmployees(): Promise<void> {
    let page = 1;
    let hasNext = true;

    while (hasNext) {
      const response = await axios.get(
        `${this.apiUrl}/employees`,
        {
          params: { page, limit: 50 },
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const { employees, pagination } = response.data;

      for (const emp of employees) {
        await this.syncEmployee(emp.employeeId);
      }

      hasNext = pagination.hasNext;
      page++;
    }

    console.log('All employees synced');
  }
}
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] syncEmployee()ãŒå‹•ä½œã™ã‚‹
- [ ] syncAllEmployees()ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

---

#### 2-3. åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´: OrganizationAnalyticsç”¨APIï¼ˆ1æ—¥ï¼‰ğŸ†•

**ç›®çš„**: OrganizationAnalyticsãƒšãƒ¼ã‚¸ã§å¿…è¦ãªéƒ¨é–€ãƒã‚¹ã‚¿ã¨è·å“¡ç·æ•°ã‚’æä¾›

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/api/routes/organization.routes.ts`

```typescript
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateAPI } from '../middleware/auth';

const router = Router();
const prisma = new PrismaClient();

/**
 * GET /api/v2/departments
 * éƒ¨é–€ãƒã‚¹ã‚¿å–å¾—ï¼ˆVoiceDrive OrganizationAnalyticsç”¨ï¼‰
 */
router.get('/departments', authenticateAPI, async (req, res) => {
  try {
    const departments = await prisma.department.findMany({
      select: {
        id: true,
        name: true,
        facilityId: true,
        facilityName: true,
        parentDepartmentId: true,
        isActive: true
      },
      where: {
        isActive: true
      },
      orderBy: [
        { facilityId: 'asc' },
        { name: 'asc' }
      ]
    });

    res.json({
      departments,
      totalCount: departments.length,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching departments:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/v2/employees/count
 * è·å“¡ç·æ•°å–å¾—ï¼ˆæ–½è¨­åˆ¥ãƒ»éƒ¨é–€åˆ¥ã®é›†è¨ˆï¼‰
 */
router.get('/employees/count', authenticateAPI, async (req, res) => {
  try {
    const { facility, department } = req.query;

    // åŸºæœ¬æ¡ä»¶: åœ¨è·ä¸­ã®è·å“¡ã®ã¿
    const baseWhere = { isActive: true };

    // ç·æ•°
    const totalCount = await prisma.employee.count({
      where: baseWhere
    });

    // æ–½è¨­åˆ¥é›†è¨ˆ
    const byFacility = await prisma.employee.groupBy({
      by: ['facility'],
      where: baseWhere,
      _count: {
        employeeId: true
      }
    });

    // éƒ¨é–€åˆ¥é›†è¨ˆ
    const byDepartment = await prisma.employee.groupBy({
      by: ['department'],
      where: baseWhere,
      _count: {
        employeeId: true
      }
    });

    // ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨
    let filteredCount = totalCount;
    if (facility || department) {
      const filterWhere: any = { ...baseWhere };
      if (facility) filterWhere.facility = facility;
      if (department) filterWhere.department = department;

      filteredCount = await prisma.employee.count({
        where: filterWhere
      });
    }

    res.json({
      totalCount,
      filteredCount,
      byFacility: byFacility.map(f => ({
        facility: f.facility,
        count: f._count.employeeId
      })),
      byDepartment: byDepartment.map(d => ({
        department: d.department,
        count: d._count.employeeId
      })),
      filters: { facility, department },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching employee count:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] GET /api/v2/departments ãŒå‹•ä½œã™ã‚‹
- [ ] GET /api/v2/employees/count ãŒå‹•ä½œã™ã‚‹
- [ ] èªè¨¼ï¼ˆJWT/APIã‚­ãƒ¼ï¼‰ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] æ–½è¨­åˆ¥ãƒ»éƒ¨é–€åˆ¥ã®é›†è¨ˆãŒæ­£ã—ã„
- [ ] ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ãŒ500msä»¥å†…
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**:
- `mcp-shared/docs/organization-analytics_DBè¦ä»¶åˆ†æ_20251010.md`
- `mcp-shared/docs/organization-analyticsæš«å®šãƒã‚¹ã‚¿ãƒ¼ãƒªã‚¹ãƒˆ_20251010.md`
- `mcp-shared/docs/OrganizationAnalytics_åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ é€£æºè¦ä»¶ç¢ºèªæ›¸_20251010.md`

#### 2-4. VoiceDriveå´: OrganizationAnalyticsServiceå®Ÿè£…ï¼ˆ2.5æ—¥ï¼‰ğŸ†•

**ç›®çš„**: çµ„ç¹”å…¨ä½“ã®å£°ã®æ´»æ€§åº¦ãƒ»è­°é¡Œé€²æ—ã‚’é›†è¨ˆã™ã‚‹ã‚µãƒ¼ãƒ“ã‚¹å±¤

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/services/OrganizationAnalyticsService.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import { AgendaLevel } from '@prisma/client';
import axios from 'axios';

const prisma = new PrismaClient();

export class OrganizationAnalyticsService {
  private medicalSystemApiUrl = process.env.MEDICAL_SYSTEM_API_URL;
  private medicalSystemApiKey = process.env.MEDICAL_SYSTEM_API_KEY;

  /**
   * çµ„ç¹”å¥å…¨æ€§æŒ‡æ¨™ã‚’å–å¾—
   */
  async getOrganizationHealth(
    facilityId?: string,
    startDate?: Date,
    endDate?: Date
  ) {
    const where: any = {};
    if (facilityId) where.facilityId = facilityId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = startDate;
      if (endDate) where.createdAt.lte = endDate;
    }

    // å£°ã®æ´»æ€§åº¦: æŠ•ç¨¿æ•° Ã· è·å“¡ç·æ•°
    const postCount = await prisma.post.count({ where });
    const employeeCount = await this.getEmployeeCount(facilityId);
    const voiceActivity = employeeCount > 0
      ? Math.min(100, (postCount / employeeCount) * 10)
      : 0;

    // å‚åŠ ç‡: ãƒ¦ãƒ‹ãƒ¼ã‚¯æŠ•ç¨¿è€…æ•° Ã· è·å“¡ç·æ•°
    const uniqueAuthors = await prisma.post.findMany({
      where,
      select: { authorId: true },
      distinct: ['authorId']
    });
    const participationRate = employeeCount > 0
      ? (uniqueAuthors.length / employeeCount) * 100
      : 0;

    // è§£æ±ºç‡: RESOLVEDçŠ¶æ…‹ã®æŠ•ç¨¿æ•° Ã· å…¨æŠ•ç¨¿æ•°
    const resolvedCount = await prisma.post.count({
      where: { ...where, postStatus: 'RESOLVED' }
    });
    const resolutionRate = postCount > 0
      ? (resolvedCount / postCount) * 100
      : 0;

    // ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚¹ã‚³ã‚¢: Vote + Comment ã®ç·æ•°
    const voteCount = await prisma.vote.count({
      where: { post: where }
    });
    const commentCount = await prisma.comment.count({
      where: { post: where }
    });
    const engagementScore = Math.min(100, (voteCount + commentCount) / 10);

    // éƒ¨é–€é–“é€£æº: è¤‡æ•°éƒ¨é–€ã®ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚‹æŠ•ç¨¿ã®å‰²åˆ
    const postsWithMultiDepts = await this.getPostsWithCrossDeptEngagement(where);
    const crossDeptCollaboration = postCount > 0
      ? (postsWithMultiDepts / postCount) * 100
      : 0;

    return {
      voiceActivity: Math.round(voiceActivity),
      participationRate: Math.round(participationRate),
      resolutionRate: Math.round(resolutionRate),
      engagementScore: Math.round(engagementScore),
      crossDeptCollaboration: Math.round(crossDeptCollaboration)
    };
  }

  /**
   * è­°é¡Œé€²æ—çŠ¶æ³ã‚’å–å¾—
   */
  async getAgendaProgress(facilityId?: string) {
    const where: any = {};
    if (facilityId) where.facilityId = facilityId;

    const [
      departmentLevel,
      facilityLevel,
      corporateLevel,
      committeeSubmitted,
      resolved
    ] = await Promise.all([
      prisma.post.count({ where: { ...where, agendaLevel: 'DEPT_AGENDA' } }),
      prisma.post.count({ where: { ...where, agendaLevel: 'FACILITY_AGENDA' } }),
      prisma.post.count({ where: { ...where, agendaLevel: 'CORP_AGENDA' } }),
      prisma.managementCommitteeAgenda.count({
        where: { status: 'submitted', facilityId }
      }),
      prisma.managementCommitteeAgenda.count({
        where: { status: 'resolved', facilityId }
      })
    ]);

    return {
      departmentLevel,
      facilityLevel,
      corporateLevel,
      committeeSubmitted,
      resolved
    };
  }

  /**
   * åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰è·å“¡ç·æ•°ã‚’å–å¾—
   */
  private async getEmployeeCount(facilityId?: string): Promise<number> {
    try {
      const params = facilityId ? { facility: facilityId } : {};
      const response = await axios.get(
        `${this.medicalSystemApiUrl}/api/v2/employees/count`,
        {
          headers: {
            Authorization: `Bearer ${this.medicalSystemApiKey}`
          },
          params
        }
      );
      return response.data.filteredCount || response.data.totalCount;
    } catch (error) {
      console.error('Error fetching employee count:', error);
      return 0;
    }
  }

  /**
   * è¤‡æ•°éƒ¨é–€ã‹ã‚‰ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚‹æŠ•ç¨¿æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
   */
  private async getPostsWithCrossDeptEngagement(where: any): Promise<number> {
    const posts = await prisma.post.findMany({
      where,
      include: {
        comments: {
          include: {
            author: { select: { department: true } }
          }
        }
      }
    });

    return posts.filter(post => {
      const departments = new Set(
        post.comments.map(c => c.author?.department).filter(Boolean)
      );
      return departments.size >= 2;
    }).length;
  }
}
```

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/pages/api/organization-analytics.ts`

```typescript
import type { NextApiRequest, NextApiResponse } from 'next';
import { OrganizationAnalyticsService } from '@/services/OrganizationAnalyticsService';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { facilityId, startDate, endDate } = req.query;

  try {
    const service = new OrganizationAnalyticsService();

    const [organizationHealth, agendaProgress] = await Promise.all([
      service.getOrganizationHealth(
        facilityId as string,
        startDate ? new Date(startDate as string) : undefined,
        endDate ? new Date(endDate as string) : undefined
      ),
      service.getAgendaProgress(facilityId as string)
    ]);

    res.status(200).json({
      organizationHealth,
      agendaProgress,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching organization analytics:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] OrganizationAnalyticsService.getOrganizationHealth() ãŒå‹•ä½œã™ã‚‹
- [ ] OrganizationAnalyticsService.getAgendaProgress() ãŒå‹•ä½œã™ã‚‹
- [ ] GET /api/organization-analytics ãŒå‹•ä½œã™ã‚‹
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ APIé€£æºï¼ˆè·å“¡ç·æ•°å–å¾—ï¼‰ãŒå‹•ä½œã™ã‚‹
- [ ] æ–½è¨­ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- [ ] æ—¥ä»˜ç¯„å›²ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ 3ç§’ä»¥å†…ï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

**æ¨å®šå·¥æ•°**: 2.5æ—¥
- é›†è¨ˆãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…: 1.5æ—¥
- APIçµ±åˆ: 0.5æ—¥
- ãƒ†ã‚¹ãƒˆãƒ»èª¿æ•´: 0.5æ—¥

### Phase 3: Webhookå®Ÿè£…ï¼ˆ3æ—¥ï¼‰

#### 3-1. åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´: Webhooké€ä¿¡æ©Ÿèƒ½

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/services/WebhookService.ts`

```typescript
import axios from 'axios';
import crypto from 'crypto';

export class WebhookService {
  private voiceDriveUrl = process.env.VOICEDRIVE_API_URL;
  private secret = process.env.WEBHOOK_SECRET!;

  /**
   * HMAC-SHA256ç½²åç”Ÿæˆ
   */
  private generateSignature(payload: string): string {
    return crypto
      .createHmac('sha256', this.secret)
      .update(payload)
      .digest('hex');
  }

  /**
   * Webhooké€ä¿¡
   */
  async sendWebhook(
    endpoint: string,
    eventType: string,
    data: any
  ): Promise<void> {
    const payload = {
      eventType,
      timestamp: new Date().toISOString(),
      data
    };

    const payloadString = JSON.stringify(payload);
    const signature = this.generateSignature(payloadString);

    try {
      await axios.post(
        `${this.voiceDriveUrl}/webhooks/${endpoint}`,
        payload,
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Medical-System-Signature': `sha256=${signature}`
          },
          timeout: 10000
        }
      );

      console.log(`Webhook sent: ${eventType}`);
    } catch (error) {
      console.error(`Error sending webhook ${eventType}:`, error);
      // TODO: ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
      throw error;
    }
  }

  /**
   * è·å“¡å…¥ç¤¾é€šçŸ¥
   */
  async notifyEmployeeCreated(employeeId: string): Promise<void> {
    const employee = await prisma.employee.findUnique({
      where: { employeeId }
    });

    if (!employee) return;

    await this.sendWebhook('employee-created', 'employee.created', {
      employeeId: employee.employeeId,
      name: employee.name,
      email: employee.email,
      department: employee.department,
      facility: employee.facility,
      hireDate: employee.hireDate
    });
  }

  /**
   * è·å“¡æƒ…å ±å¤‰æ›´é€šçŸ¥
   */
  async notifyEmployeeUpdated(
    employeeId: string,
    changes: any
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.updated', {
      employeeId,
      changes
    });
  }

  /**
   * éƒ¨ç½²ç•°å‹•é€šçŸ¥
   */
  async notifyDepartmentChanged(
    employeeId: string,
    newDepartment: string,
    previousDepartment: string,
    effectiveDate: Date
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.department_changed', {
      employeeId,
      department: newDepartment,
      previousDepartment,
      effectiveDate: effectiveDate.toISOString()
    });
  }

  /**
   * æ¨©é™ãƒ¬ãƒ™ãƒ«å¤‰æ›´é€šçŸ¥
   */
  async notifyPermissionChanged(
    employeeId: string,
    newPermissionLevel: number,
    canPerformLeaderDuty: boolean
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.permission_changed', {
      employeeId,
      newPermissionLevel,
      canPerformLeaderDuty
    });
  }

  /**
   * é¢è«‡çµæœé€šçŸ¥
   */
  async notifyInterviewCompleted(interviewId: string): Promise<void> {
    const interview = await prisma.interview.findUnique({
      where: { id: interviewId },
      include: { employee: true }
    });

    if (!interview) return;

    await this.sendWebhook('interview-completed', 'interview.completed', {
      interviewId: interview.id,
      employeeId: interview.employeeId,
      interviewDate: interview.interviewDate,
      interviewType: interview.interviewType,
      completedAt: interview.completedAt,
      summary: interview.summary,
      keyPoints: interview.keyPoints,
      feedbackToEmployee: interview.feedbackSummary,
      followUpRequired: interview.followUpRequired
    });
  }
}
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] HMAC-SHA256ç½²åãŒæ­£ã—ãç”Ÿæˆã•ã‚Œã‚‹
- [ ] Webhooké€ä¿¡ãŒæˆåŠŸã™ã‚‹
- [ ] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

#### 3-2. VoiceDriveå´: Webhookå—ä¿¡ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/api/routes/webhook.routes.ts`

```typescript
import { Router } from 'express';
import crypto from 'crypto';
import { EmployeeSyncService } from '../../services/EmployeeSyncService';

const router = Router();
const syncService = new EmployeeSyncService();

/**
 * Webhookç½²åæ¤œè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 */
function verifyWebhookSignature(req: any, res: any, next: any) {
  const signature = req.headers['x-medical-system-signature'];
  const secret = process.env.WEBHOOK_SECRET!;

  if (!signature) {
    return res.status(401).json({ error: 'Missing signature' });
  }

  const payloadString = JSON.stringify(req.body);
  const expectedSignature = 'sha256=' + crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');

  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  next();
}

/**
 * POST /api/webhooks/employee-created
 * è·å“¡å…¥ç¤¾é€šçŸ¥
 */
router.post('/employee-created', verifyWebhookSignature, async (req, res) => {
  try {
    const { data } = req.body;
    await syncService.syncEmployee(data.employeeId);
    res.json({ success: true });
  } catch (error) {
    console.error('Error handling employee-created webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * POST /api/webhooks/employee-updated
 * è·å“¡æƒ…å ±å¤‰æ›´é€šçŸ¥
 */
router.post('/employee-updated', verifyWebhookSignature, async (req, res) => {
  try {
    const { eventType, data } = req.body;

    switch (eventType) {
      case 'employee.department_changed':
        await syncService.syncEmployee(data.employeeId);
        // æŠ•ç¨¿å¯è¦–æ€§å†è¨ˆç®—
        await recalculatePostVisibility(data.employeeId);
        break;

      case 'employee.permission_changed':
        await syncService.syncEmployee(data.employeeId);
        // ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™å†è©•ä¾¡
        await reevaluatePermissions(data.employeeId);
        break;

      default:
        await syncService.syncEmployee(data.employeeId);
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Error handling employee-updated webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * POST /api/webhooks/interview-completed
 * é¢è«‡çµæœé€šçŸ¥
 */
router.post('/interview-completed', verifyWebhookSignature, async (req, res) => {
  try {
    const { data } = req.body;

    // InterviewResultãƒ†ãƒ¼ãƒ–ãƒ«ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    await prisma.interviewResult.create({
      data: {
        requestId: data.interviewId,
        interviewId: data.interviewId,
        completedAt: new Date(data.completedAt),
        duration: data.duration || 60,
        summary: data.summary,
        keyPoints: data.keyPoints,
        actionItems: data.actionItems || [],
        followUpRequired: data.followUpRequired,
        followUpDate: data.followUpDate ? new Date(data.followUpDate) : null,
        feedbackToEmployee: data.feedbackToEmployee,
        nextRecommendations: data.nextRecommendations || [],
        status: 'received',
        processedAt: new Date()
      }
    });

    // è·å“¡ã«é€šçŸ¥
    await sendNotificationToEmployee(data.employeeId, {
      title: 'é¢è«‡çµæœãŒåˆ©ç”¨å¯èƒ½ã§ã™',
      message: 'é¢è«‡ã®çµæœã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒç¢ºèªã§ãã¾ã™ã€‚'
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error handling interview-completed webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] Webhookç½²åæ¤œè¨¼ãŒå‹•ä½œã™ã‚‹
- [ ] employee-created ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒå‹•ä½œã™ã‚‹
- [ ] employee-updated ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒå‹•ä½œã™ã‚‹
- [ ] interview-completed ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

---

### Phase 4: çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆ2æ—¥ï¼‰

#### 4-1. æ‰‹å‹•çµ±åˆãƒ†ã‚¹ãƒˆ

**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1: è·å“¡å…¥ç¤¾ãƒ•ãƒ­ãƒ¼**
```bash
# åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´
curl -X POST http://localhost:8080/api/employees \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "employeeId": "OH-NS-2024-TEST-001",
    "name": "ãƒ†ã‚¹ãƒˆ å¤ªéƒ",
    "email": "test.taro@example.com",
    "department": "å†…ç§‘",
    "facility": "obara-hospital",
    "hireDate": "2024-10-08"
  }'

# VoiceDriveå´ã§ç¢ºèª
curl http://localhost:3001/api/users/OH-NS-2024-TEST-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**æœŸå¾…çµæœ**:
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã§Employeeä½œæˆæˆåŠŸ
- [ ] WebhookãŒVoiceDriveã«é€ä¿¡ã•ã‚Œã‚‹
- [ ] VoiceDriveã§Userä½œæˆæˆåŠŸ
- [ ] Userãƒ‡ãƒ¼ã‚¿ãŒåŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã¨ä¸€è‡´

**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2: éƒ¨ç½²ç•°å‹•ãƒ•ãƒ­ãƒ¼**
```bash
# åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´
curl -X PATCH http://localhost:8080/api/employees/OH-NS-2024-TEST-001/department \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "newDepartment": "å¤–ç§‘",
    "effectiveDate": "2024-11-01"
  }'

# VoiceDriveå´ã§ç¢ºèª
curl http://localhost:3001/api/users/OH-NS-2024-TEST-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**æœŸå¾…çµæœ**:
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã§éƒ¨ç½²ç•°å‹•å‡¦ç†æˆåŠŸ
- [ ] AssignmentHistoryä½œæˆ
- [ ] WebhookãŒVoiceDriveã«é€ä¿¡ã•ã‚Œã‚‹
- [ ] VoiceDriveã®User.departmentæ›´æ–°
- [ ] æŠ•ç¨¿å¯è¦–æ€§ãŒå†è¨ˆç®—ã•ã‚Œã‚‹

**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹3: é¢è«‡çµæœé€šçŸ¥ãƒ•ãƒ­ãƒ¼**
```bash
# åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ å´ï¼ˆé¢è«‡å®Œäº†ï¼‰
curl -X POST http://localhost:8080/api/interviews/INT-001/complete \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "summary": "å‰å‘ããªå§¿å‹¢ãŒè¦‹ã‚‰ã‚Œã‚‹",
    "feedbackToEmployee": "å¼•ãç¶šãé ‘å¼µã£ã¦ãã ã•ã„"
  }'

# VoiceDriveå´ã§ç¢ºèª
curl http://localhost:3001/api/interview-results/INT-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**æœŸå¾…çµæœ**:
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã§é¢è«‡è¨˜éŒ²ä½œæˆ
- [ ] AIåˆ†æå®Ÿè¡Œ
- [ ] WebhookãŒVoiceDriveã«é€ä¿¡ã•ã‚Œã‚‹
- [ ] VoiceDriveã®InterviewResultä½œæˆ
- [ ] è·å“¡ã«é€šçŸ¥ãŒé€ä¿¡ã•ã‚Œã‚‹

#### 4-2. è‡ªå‹•çµ±åˆãƒ†ã‚¹ãƒˆ

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `tests/integration/employee-sync.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import axios from 'axios';

describe('Employee Sync Integration Tests', () => {
  const medicalApiUrl = 'http://localhost:8080/api';
  const voiceDriveApiUrl = 'http://localhost:3001/api';
  const testEmployeeId = `TEST-${Date.now()}`;

  beforeAll(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  });

  afterAll(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  });

  it('should sync employee on creation', async () => {
    // åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ã§è·å“¡ä½œæˆ
    const createResponse = await axios.post(
      `${medicalApiUrl}/employees`,
      {
        employeeId: testEmployeeId,
        name: 'ãƒ†ã‚¹ãƒˆ å¤ªéƒ',
        email: `${testEmployeeId}@example.com`,
        department: 'å†…ç§‘'
      },
      { headers: { Authorization: `Bearer ${process.env.API_KEY}` } }
    );

    expect(createResponse.status).toBe(201);

    // 5ç§’å¾…æ©Ÿï¼ˆWebhookå‡¦ç†ï¼‰
    await new Promise(resolve => setTimeout(resolve, 5000));

    // VoiceDriveã§ç¢ºèª
    const voiceDriveResponse = await axios.get(
      `${voiceDriveApiUrl}/users/${testEmployeeId}`,
      { headers: { Authorization: `Bearer ${process.env.JWT_TOKEN}` } }
    );

    expect(voiceDriveResponse.status).toBe(200);
    expect(voiceDriveResponse.data.employeeId).toBe(testEmployeeId);
    expect(voiceDriveResponse.data.name).toBe('ãƒ†ã‚¹ãƒˆ å¤ªéƒ');
  });

  it('should sync department change', async () => {
    // éƒ¨ç½²ç•°å‹•
    await axios.patch(
      `${medicalApiUrl}/employees/${testEmployeeId}/department`,
      { newDepartment: 'å¤–ç§‘' },
      { headers: { Authorization: `Bearer ${process.env.API_KEY}` } }
    );

    await new Promise(resolve => setTimeout(resolve, 5000));

    // VoiceDriveã§ç¢ºèª
    const response = await axios.get(
      `${voiceDriveApiUrl}/users/${testEmployeeId}`,
      { headers: { Authorization: `Bearer ${process.env.JWT_TOKEN}` } }
    );

    expect(response.data.department).toBe('å¤–ç§‘');
  });
});
```

**ãƒã‚§ãƒƒã‚¯é …ç›®**:
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆãŒå…¨ã¦é€šéã™ã‚‹
- [ ] CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«çµ±åˆã•ã‚Œã¦ã„ã‚‹

---

### Phase 5: ç›£è¦–ãƒ»ãƒ­ã‚®ãƒ³ã‚°ï¼ˆ1æ—¥ï¼‰

#### 5-1. ãƒ­ã‚®ãƒ³ã‚°å®Ÿè£…

**å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«**: `src/utils/logger.ts`

```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// çµ±åˆãƒ­ã‚°ç”¨
export const integrationLogger = logger.child({ component: 'integration' });
```

**ä½¿ç”¨ä¾‹**:
```typescript
integrationLogger.info('Employee synced', {
  employeeId: 'OH-NS-2024-001',
  action: 'sync',
  source: 'webhook'
});

integrationLogger.error('Webhook failed', {
  eventType: 'employee.created',
  error: error.message
});
```

#### 5-2. ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

**ãƒ¡ãƒˆãƒªã‚¯ã‚¹**:
- WebhookæˆåŠŸç‡
- APIå¿œç­”æ™‚é–“
- åŒæœŸã‚¨ãƒ©ãƒ¼ç‡
- ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯çµæœ

**ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š**:
- Webhookå¤±æ•—ç‡ > 1%
- APIå¿œç­”æ™‚é–“ > 1ç§’
- ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆæ¤œå‡ºæ™‚

---

## ğŸ“‹ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### ç’°å¢ƒæº–å‚™
- [ ] MySQLç’°å¢ƒæ§‹ç¯‰å®Œäº†ï¼ˆAWS Lightsailï¼‰
- [ ] VoiceDrive DBä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ DBä½œæˆãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
- [ ] ç’°å¢ƒå¤‰æ•°è¨­å®šå®Œäº†ï¼ˆä¸¡ã‚·ã‚¹ãƒ†ãƒ ï¼‰
- [ ] ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šç¢ºèªå®Œäº†

### APIå®Ÿè£…
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ : GET /api/employees/:id å®Ÿè£…
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ : GET /api/employees å®Ÿè£…
- [ ] VoiceDrive: EmployeeSyncServiceå®Ÿè£…
- [ ] èªè¨¼ãƒ»èªå¯å®Ÿè£…
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…
- [ ] ãƒ¬ãƒ¼ãƒˆåˆ¶é™å®Ÿè£…

### Webhookå®Ÿè£…
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ : WebhookServiceå®Ÿè£…
- [ ] åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ : ç½²åç”Ÿæˆå®Ÿè£…
- [ ] VoiceDrive: Webhookå—ä¿¡ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…
- [ ] VoiceDrive: ç½²åæ¤œè¨¼å®Ÿè£…
- [ ] ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°è¨˜éŒ²å®Ÿè£…

### ãƒ†ã‚¹ãƒˆ
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆå®Ÿè£…ãƒ»é€šé
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè£…ãƒ»é€šé
- [ ] æ‰‹å‹•ãƒ†ã‚¹ãƒˆå®Ÿæ–½ãƒ»å®Œäº†
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿæ–½
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå®Ÿæ–½

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [ ] APIä»•æ§˜æ›¸ä½œæˆï¼ˆOpenAPI 3.0ï¼‰
- [ ] Webhookä»•æ§˜æ›¸ä½œæˆ
- [ ] é‹ç”¨æ‰‹é †æ›¸ä½œæˆ
- [ ] ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ä½œæˆ

### ç›£è¦–ãƒ»é‹ç”¨
- [ ] ãƒ­ã‚®ãƒ³ã‚°å®Ÿè£…
- [ ] ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ§‹ç¯‰
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š
- [ ] éšœå®³å¯¾å¿œæ‰‹é †æ›¸ä½œæˆ

---

## ğŸš¨ æƒ³å®šã•ã‚Œã‚‹ãƒªã‚¹ã‚¯ã¨å¯¾ç­–

### ãƒªã‚¹ã‚¯1: Webhooké…ä¿¡å¤±æ•—

**åŸå› **:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³
- VoiceDriveã‚µãƒ¼ãƒãƒ¼ãƒ€ã‚¦ãƒ³
- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

**å¯¾ç­–**:
- ãƒªãƒˆãƒ©ã‚¤ã‚­ãƒ¥ãƒ¼å®Ÿè£…ï¼ˆRedisä½¿ç”¨ï¼‰
- æœ€å¤§3å›ãƒªãƒˆãƒ©ã‚¤
- å¤±æ•—æ™‚ã¯ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥
- æ‰‹å‹•å†é€æ©Ÿèƒ½å®Ÿè£…

### ãƒªã‚¹ã‚¯2: ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆ

**åŸå› **:
- åŒæœŸå‡¦ç†ã®å¤±æ•—
- ç«¶åˆçŠ¶æ…‹ï¼ˆrace conditionï¼‰
- éƒ¨åˆ†çš„ãªæ›´æ–°å¤±æ•—

**å¯¾ç­–**:
- æ—¥æ¬¡ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ãƒãƒƒãƒ
- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†
- æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ï¼ˆoptimistic lockingï¼‰
- ä¸æ•´åˆæ¤œå‡ºæ™‚ã®è‡ªå‹•ä¿®æ­£

### ãƒªã‚¹ã‚¯3: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹

**åŸå› **:
- å¤§é‡ãƒ‡ãƒ¼ã‚¿åŒæœŸ
- APIå‘¼ã³å‡ºã—ã®å¢—åŠ 
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã®éåŠ¹ç‡

**å¯¾ç­–**:
- ãƒãƒƒãƒåŒæœŸã®æœ€é©åŒ–
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ï¼ˆRedisï¼‰
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
- éåŒæœŸå‡¦ç†ã®æ´»ç”¨

---

## ğŸ“Š æˆåŠŸæŒ‡æ¨™ï¼ˆKPIï¼‰

### Phase 1-3å®Œäº†æ™‚
- [ ] å…¨APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒæ­£å¸¸å‹•ä½œï¼ˆ100%ï¼‰
- [ ] WebhookæˆåŠŸç‡ > 95%
- [ ] APIå¿œç­”æ™‚é–“ < 500msï¼ˆP95ï¼‰
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆåˆæ ¼ç‡ 100%

### Phase 4-5å®Œäº†æ™‚
- [ ] ãƒ‡ãƒ¼ã‚¿åŒæœŸç²¾åº¦ > 99.9%
- [ ] WebhookæˆåŠŸç‡ > 99%
- [ ] ã‚·ã‚¹ãƒ†ãƒ å¯ç”¨æ€§ > 99.5%
- [ ] ã‚¨ãƒ©ãƒ¼ç‡ < 0.1%

---

## ğŸ“ é€£çµ¡å…ˆãƒ»ãƒªã‚½ãƒ¼ã‚¹

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»åˆ†ç•Œç‚¹å®šç¾©æ›¸](./ãƒ‡ãƒ¼ã‚¿ç®¡ç†è²¬ä»»åˆ†ç•Œç‚¹å®šç¾©æ›¸_20251008.md)
- [MySQL_Migration_Guide.md](../../docs/MySQL_Migration_Guide.md)
- [VoiceDrive_MySQL_Migration_Request_20251008.md](./VoiceDrive_MySQL_Migration_Request_20251008.md)

### æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **DB**: MySQL 8.0
- **ORM**: Prisma
- **API**: Express.js (Node.js)
- **èªè¨¼**: JWT + APIã‚­ãƒ¼
- **Webhook**: HMAC-SHA256ç½²å
- **ç›£è¦–**: Winston (ãƒ­ã‚°), Prometheus (ãƒ¡ãƒˆãƒªã‚¯ã‚¹)

### Git Commitsï¼ˆå‚ç…§ç”¨ï¼‰
- `74fb6cc`: validateEnv.tsä½œæˆ
- `f9db560`: Prisma schema MySQLå¯¾å¿œ
- `0b17d07`: MySQL_Migration_Guide.mdä½œæˆ
- `3be6b51`: å®Œäº†å ±å‘Šæ›¸ä½œæˆ
- `a89ac48`: åŒ»ç™‚ãƒãƒ¼ãƒ ã¸ã®ä¾é ¼æ–‡æ›¸ä½œæˆ

---

## ğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

1. **MySQLç’°å¢ƒæ§‹ç¯‰å®Œäº†ã‚’å¾…ã¤**
   - åŒ»ç™‚ã‚·ã‚¹ãƒ†ãƒ ãƒãƒ¼ãƒ ã«é€²æ—ç¢ºèª
   - AWS Lightsailæ§‹ç¯‰çŠ¶æ³ç¢ºèª

2. **æ§‹ç¯‰å®Œäº†å¾Œã€å³åº§ã«Phase 1é–‹å§‹**
   - ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«å¾“ã£ã¦ä½œæ¥­
   - å„Phaseã”ã¨ã«ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆç¢ºèª
   - å•é¡Œç™ºç”Ÿæ™‚ã¯å³åº§ã«ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

3. **å®šä¾‹ä¼šè­°ã§é€²æ—å ±å‘Š**
   - æ¯é€±æœˆæ›œ 10:00-11:00
   - çµ±åˆä½œæ¥­ã®é€²æ—å…±æœ‰
   - èª²é¡Œãƒ»ãƒªã‚¹ã‚¯ã®å…±æœ‰

---

**æ–‡æ›¸çµ‚äº†**

æœ€çµ‚æ›´æ–°: 2025å¹´10æœˆ10æ—¥
ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.1ï¼ˆOrganizationAnalyticsè¦ä»¶è¿½åŠ ï¼‰
æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼: DBæ§‹ç¯‰å®Œäº†å¾Œ
