# 共通DB構築後統合作業再開計画書

**文書番号**: INT-PLAN-2025-1008-001
**作成日**: 2025年10月8日
**作成者**: VoiceDriveチーム
**目的**: MySQL DB構築完了後、VoiceDriveと医療システムの統合作業を円滑に再開するための計画書
**重要度**: 🔴 最重要
**前提文書**: [データ管理責任分界点定義書_20251008.md](./データ管理責任分界点定義書_20251008.md)

---

## 📋 エグゼクティブサマリー

### 現在の状況（2025年10月10日時点）

#### ✅ 完了した作業
1. **データ管理責任分界点定義書の作成**（2025年10月8日）
   - VoiceDriveと医療システム間のデータ管理責任を明確化
   - 10カテゴリ、60項目以上のデータ項目を分析
   - API/Webhook連携方式を定義

2. **VoiceDrive MySQL移行準備完了**（2025年10月8日）
   - `validateEnv.ts` 作成（環境変数バリデーション）
   - `prisma/schema.prisma` をMySQL対応に変更
   - `MySQL_Migration_Guide.md` 作成（292行）
   - `.env`, `.env.production` をMySQL接続文字列に更新
   - Git commits: 74fb6cc, f9db560, 0b17d07, 3be6b51, a89ac48

3. **医療システムDB構築計画書の分析**（2025年10月8日）
   - 全12,118行、29セクション、146テーブルの構築計画を完全分析
   - VoiceDriveとの重複・連携ポイントを特定

4. **PersonalStationページのDB要件分析完了**（2025年10月8-9日）
   - [PersonalStation_DB要件分析_20251008.md](./PersonalStation_DB要件分析_20251008.md) 作成
   - [PersonalStation暫定マスターリスト_20251008.md](./PersonalStation暫定マスターリスト_20251008.md) 作成
   - 医療システムへのAPI依頼2件、Webhook依頼4件を明確化
   - 推定工数: 医療システム側2日、VoiceDrive側5-8日

5. **OrganizationAnalyticsページのDB要件分析完了**（2025年10月10日）🆕
   - [organization-analytics_DB要件分析_20251010.md](./organization-analytics_DB要件分析_20251010.md) 作成
   - [organization-analytics暫定マスターリスト_20251010.md](./organization-analytics暫定マスターリスト_20251010.md) 作成
   - [OrganizationAnalytics_医療システム連携要件確認書_20251010.md](./OrganizationAnalytics_医療システム連携要件確認書_20251010.md) 作成
   - 医療システムへのAPI依頼2件、確認事項2件を明確化
   - schema.prisma更新（ManagementCommitteeAgendaに実装追跡フィールド追加）
   - 推定工数: 医療システム側2.5日、VoiceDrive側3.5日

#### ⏳ 保留中の作業（DB構築待ち）
1. **MySQL環境構築**（医療システム側）
   - AWS Lightsail統合インスタンス構築
   - MySQL 8.0セットアップ
   - 医療システムDB作成

2. **VoiceDrive MySQL移行実行**
   - `prisma migrate deploy`
   - データ移行バッチ実行
   - 動作確認

3. **統合作業**（本計画書の対象）
   - API実装
   - Webhook実装
   - 統合テスト

---

## 🎯 DB構築完了後の作業フロー

### Phase 1: 環境確認・準備（1日）

#### 1-1. MySQL環境確認
```bash
# 医療システム側で実行
mysql -u root -p -e "SELECT VERSION();"
mysql -u root -p -e "SHOW DATABASES;"
mysql -u root -p -e "SELECT User, Host FROM mysql.user;"

# VoiceDrive側で実行
cd /c/projects/voicedrive-v100
npm run db:test-connection
```

**チェック項目**:
- [ ] MySQL 8.0が正常に起動している
- [ ] 医療システムDB（`staff_medical_system`）が存在する
- [ ] VoiceDriveDB（`voicedrive_prod`）が存在する
- [ ] 両方のDBにアクセス可能
- [ ] 文字コードがUTF-8（utf8mb4）
- [ ] タイムゾーンが正しく設定されている

#### 1-2. Prismaマイグレーション実行

**VoiceDrive側**:
```bash
cd /c/projects/voicedrive-v100

# マイグレーション実行
npx prisma migrate deploy

# 確認
npx prisma db pull
npx prisma generate

# テスト
npm run test:db
```

**医療システム側**:
```bash
cd /c/projects/staff-medical-system

# マイグレーション実行
npx prisma migrate deploy

# 確認
npx prisma db pull
npx prisma generate

# テスト
npm run test:db
```

**チェック項目**:
- [ ] VoiceDrive: 全テーブル作成完了（User, Notification, Interview, Evaluation等）
- [ ] 医療システム: 全146テーブル作成完了
- [ ] Prisma Clientが正常に生成される
- [ ] 基本的なCRUD操作が動作する

#### 1-3. 環境変数確認

**VoiceDrive `.env`**:
```env
# MySQL接続
DATABASE_URL="mysql://voicedrive_user:${DB_PASSWORD}@localhost:3306/voicedrive_prod"

# 医療システムAPI接続
MEDICAL_SYSTEM_API_URL="http://localhost:8080/api"
MEDICAL_SYSTEM_API_KEY="${MEDICAL_API_KEY}"

# Webhook署名検証
WEBHOOK_SECRET="${WEBHOOK_SECRET}"

# JWT
JWT_SECRET="${JWT_SECRET}"
```

**医療システム `.env`**:
```env
# MySQL接続
DATABASE_URL="mysql://medical_user:${DB_PASSWORD}@localhost:3306/staff_medical_system"

# VoiceDriveAPI接続
VOICEDRIVE_API_URL="http://localhost:3001/api"
VOICEDRIVE_API_KEY="${VOICEDRIVE_API_KEY}"

# Webhook署名検証
WEBHOOK_SECRET="${WEBHOOK_SECRET}"
```

**チェック項目**:
- [ ] DATABASE_URLが正しい
- [ ] 相互のAPI URLが設定されている
- [ ] APIキーが設定されている
- [ ] Webhook署名用シークレットが設定されている（同一値）

---

### Phase 2: 基本API実装（6.5日）🔄

**更新**: OrganizationAnalytics用APIとサービス実装を追加（+3.5日）
- 医療システム側: 部門マスタ・職員総数API（+1日）
- VoiceDrive側: OrganizationAnalyticsService（+2.5日）

#### 2-1. 医療システム側: 職員情報提供API

**実装ファイル**: `src/api/routes/employee.routes.ts`

```typescript
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateAPI } from '../middleware/auth';

const router = Router();
const prisma = new PrismaClient();

/**
 * GET /api/employees/:employeeId
 * 職員情報取得（VoiceDrive用）
 */
router.get('/:employeeId', authenticateAPI, async (req, res) => {
  try {
    const { employeeId } = req.params;

    const employee = await prisma.employee.findUnique({
      where: { employeeId },
      select: {
        employeeId: true,
        name: true,
        nameKana: true,
        email: true,
        department: true,
        facility: true,
        position: true,
        permissionLevel: true,
        canPerformLeaderDuty: true,
        professionCategory: true,
        parentId: true,
        hireDate: true,
        yearsOfService: true,
        isActive: true,
        // 個人情報は含めない
        // phone: false,
        // birthDate: false,
        // address: false,
      }
    });

    if (!employee) {
      return res.status(404).json({ error: 'Employee not found' });
    }

    // VoiceDrive用に変換
    const response = {
      employeeId: employee.employeeId,
      name: employee.name,
      nameKana: employee.nameKana,
      email: employee.email,
      department: employee.department,
      facility: employee.facility,
      position: employee.position,
      permissionLevel: employee.permissionLevel,
      canPerformLeaderDuty: employee.canPerformLeaderDuty,
      professionCategory: employee.professionCategory,
      parentId: employee.parentId,
      hireDate: employee.hireDate,
      yearsOfService: employee.yearsOfService,
      totalExperienceYears: await calculateTotalExperience(employeeId),
      isActive: employee.isActive
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching employee:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/employees
 * 職員リスト取得（ページング）
 */
router.get('/', authenticateAPI, async (req, res) => {
  try {
    const {
      facility,
      department,
      page = 1,
      limit = 50,
      updatedSince
    } = req.query;

    const skip = (Number(page) - 1) * Number(limit);

    const where: any = { isActive: true };
    if (facility) where.facility = facility;
    if (department) where.department = department;
    if (updatedSince) where.updatedAt = { gte: new Date(updatedSince as string) };

    const [employees, totalCount] = await Promise.all([
      prisma.employee.findMany({
        where,
        select: {
          employeeId: true,
          name: true,
          email: true,
          department: true,
          facility: true,
          position: true,
          permissionLevel: true,
        },
        skip,
        take: Number(limit),
        orderBy: { updatedAt: 'desc' }
      }),
      prisma.employee.count({ where })
    ]);

    res.json({
      employees,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        totalCount,
        totalPages: Math.ceil(totalCount / Number(limit)),
        hasNext: skip + Number(limit) < totalCount
      },
      filters: { facility, department, updatedSince }
    });
  } catch (error) {
    console.error('Error fetching employees:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**チェック項目**:
- [ ] GET /api/employees/:employeeId が動作する
- [ ] GET /api/employees（リスト）が動作する
- [ ] 認証（JWT/APIキー）が機能する
- [ ] 個人情報（住所・電話等）が含まれていない
- [ ] ページングが正しく動作する
- [ ] エラーハンドリングが実装されている

#### 2-2. VoiceDrive側: User同期機能

**実装ファイル**: `src/services/EmployeeSyncService.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import axios from 'axios';

const prisma = new PrismaClient();

interface MedicalSystemEmployee {
  employeeId: string;
  name: string;
  nameKana?: string;
  email: string;
  department?: string;
  facility?: string;
  position?: string;
  permissionLevel: number;
  canPerformLeaderDuty: boolean;
  professionCategory?: string;
  parentId?: string;
  hireDate?: Date;
  yearsOfService?: number;
  totalExperienceYears?: number;
  isActive: boolean;
}

export class EmployeeSyncService {
  private apiUrl = process.env.MEDICAL_SYSTEM_API_URL;
  private apiKey = process.env.MEDICAL_SYSTEM_API_KEY;

  /**
   * 医療システムから職員情報を取得してUserテーブルに同期
   */
  async syncEmployee(employeeId: string): Promise<void> {
    try {
      // 医療システムAPIから取得
      const response = await axios.get<MedicalSystemEmployee>(
        `${this.apiUrl}/employees/${employeeId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const employee = response.data;

      // VoiceDrive Userテーブルに同期（upsert）
      await prisma.user.upsert({
        where: { employeeId },
        create: {
          employeeId: employee.employeeId,
          email: employee.email,
          name: employee.name,
          department: employee.department,
          facilityId: employee.facility,
          role: employee.position,
          position: employee.position,
          accountType: 'staff',
          permissionLevel: employee.permissionLevel,
          canPerformLeaderDuty: employee.canPerformLeaderDuty,
          professionCategory: employee.professionCategory,
          parentId: employee.parentId,
        },
        update: {
          email: employee.email,
          name: employee.name,
          department: employee.department,
          facilityId: employee.facility,
          role: employee.position,
          position: employee.position,
          permissionLevel: employee.permissionLevel,
          canPerformLeaderDuty: employee.canPerformLeaderDuty,
          professionCategory: employee.professionCategory,
          parentId: employee.parentId,
        }
      });

      console.log(`Employee synced: ${employeeId}`);
    } catch (error) {
      console.error(`Error syncing employee ${employeeId}:`, error);
      throw error;
    }
  }

  /**
   * 全職員を同期（初回セットアップ用）
   */
  async syncAllEmployees(): Promise<void> {
    let page = 1;
    let hasNext = true;

    while (hasNext) {
      const response = await axios.get(
        `${this.apiUrl}/employees`,
        {
          params: { page, limit: 50 },
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const { employees, pagination } = response.data;

      for (const emp of employees) {
        await this.syncEmployee(emp.employeeId);
      }

      hasNext = pagination.hasNext;
      page++;
    }

    console.log('All employees synced');
  }
}
```

**チェック項目**:
- [ ] syncEmployee()が動作する
- [ ] syncAllEmployees()が動作する
- [ ] エラーハンドリングが実装されている
- [ ] リトライロジックが実装されている

---

#### 2-3. 医療システム側: OrganizationAnalytics用API（1日）🆕

**目的**: OrganizationAnalyticsページで必要な部門マスタと職員総数を提供

**実装ファイル**: `src/api/routes/organization.routes.ts`

```typescript
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateAPI } from '../middleware/auth';

const router = Router();
const prisma = new PrismaClient();

/**
 * GET /api/v2/departments
 * 部門マスタ取得（VoiceDrive OrganizationAnalytics用）
 */
router.get('/departments', authenticateAPI, async (req, res) => {
  try {
    const departments = await prisma.department.findMany({
      select: {
        id: true,
        name: true,
        facilityId: true,
        facilityName: true,
        parentDepartmentId: true,
        isActive: true
      },
      where: {
        isActive: true
      },
      orderBy: [
        { facilityId: 'asc' },
        { name: 'asc' }
      ]
    });

    res.json({
      departments,
      totalCount: departments.length,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching departments:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/v2/employees/count
 * 職員総数取得（施設別・部門別の集計）
 */
router.get('/employees/count', authenticateAPI, async (req, res) => {
  try {
    const { facility, department } = req.query;

    // 基本条件: 在職中の職員のみ
    const baseWhere = { isActive: true };

    // 総数
    const totalCount = await prisma.employee.count({
      where: baseWhere
    });

    // 施設別集計
    const byFacility = await prisma.employee.groupBy({
      by: ['facility'],
      where: baseWhere,
      _count: {
        employeeId: true
      }
    });

    // 部門別集計
    const byDepartment = await prisma.employee.groupBy({
      by: ['department'],
      where: baseWhere,
      _count: {
        employeeId: true
      }
    });

    // フィルタ適用
    let filteredCount = totalCount;
    if (facility || department) {
      const filterWhere: any = { ...baseWhere };
      if (facility) filterWhere.facility = facility;
      if (department) filterWhere.department = department;

      filteredCount = await prisma.employee.count({
        where: filterWhere
      });
    }

    res.json({
      totalCount,
      filteredCount,
      byFacility: byFacility.map(f => ({
        facility: f.facility,
        count: f._count.employeeId
      })),
      byDepartment: byDepartment.map(d => ({
        department: d.department,
        count: d._count.employeeId
      })),
      filters: { facility, department },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching employee count:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**チェック項目**:
- [ ] GET /api/v2/departments が動作する
- [ ] GET /api/v2/employees/count が動作する
- [ ] 認証（JWT/APIキー）が機能する
- [ ] 施設別・部門別の集計が正しい
- [ ] フィルタリング機能が動作する
- [ ] レスポンスタイムが500ms以内
- [ ] エラーハンドリングが実装されている

**関連ドキュメント**:
- `mcp-shared/docs/organization-analytics_DB要件分析_20251010.md`
- `mcp-shared/docs/organization-analytics暫定マスターリスト_20251010.md`
- `mcp-shared/docs/OrganizationAnalytics_医療システム連携要件確認書_20251010.md`

#### 2-4. VoiceDrive側: OrganizationAnalyticsService実装（2.5日）🆕

**目的**: 組織全体の声の活性度・議題進捗を集計するサービス層

**実装ファイル**: `src/services/OrganizationAnalyticsService.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import { AgendaLevel } from '@prisma/client';
import axios from 'axios';

const prisma = new PrismaClient();

export class OrganizationAnalyticsService {
  private medicalSystemApiUrl = process.env.MEDICAL_SYSTEM_API_URL;
  private medicalSystemApiKey = process.env.MEDICAL_SYSTEM_API_KEY;

  /**
   * 組織健全性指標を取得
   */
  async getOrganizationHealth(
    facilityId?: string,
    startDate?: Date,
    endDate?: Date
  ) {
    const where: any = {};
    if (facilityId) where.facilityId = facilityId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = startDate;
      if (endDate) where.createdAt.lte = endDate;
    }

    // 声の活性度: 投稿数 ÷ 職員総数
    const postCount = await prisma.post.count({ where });
    const employeeCount = await this.getEmployeeCount(facilityId);
    const voiceActivity = employeeCount > 0
      ? Math.min(100, (postCount / employeeCount) * 10)
      : 0;

    // 参加率: ユニーク投稿者数 ÷ 職員総数
    const uniqueAuthors = await prisma.post.findMany({
      where,
      select: { authorId: true },
      distinct: ['authorId']
    });
    const participationRate = employeeCount > 0
      ? (uniqueAuthors.length / employeeCount) * 100
      : 0;

    // 解決率: RESOLVED状態の投稿数 ÷ 全投稿数
    const resolvedCount = await prisma.post.count({
      where: { ...where, postStatus: 'RESOLVED' }
    });
    const resolutionRate = postCount > 0
      ? (resolvedCount / postCount) * 100
      : 0;

    // エンゲージメントスコア: Vote + Comment の総数
    const voteCount = await prisma.vote.count({
      where: { post: where }
    });
    const commentCount = await prisma.comment.count({
      where: { post: where }
    });
    const engagementScore = Math.min(100, (voteCount + commentCount) / 10);

    // 部門間連携: 複数部門のコメントがある投稿の割合
    const postsWithMultiDepts = await this.getPostsWithCrossDeptEngagement(where);
    const crossDeptCollaboration = postCount > 0
      ? (postsWithMultiDepts / postCount) * 100
      : 0;

    return {
      voiceActivity: Math.round(voiceActivity),
      participationRate: Math.round(participationRate),
      resolutionRate: Math.round(resolutionRate),
      engagementScore: Math.round(engagementScore),
      crossDeptCollaboration: Math.round(crossDeptCollaboration)
    };
  }

  /**
   * 議題進捗状況を取得
   */
  async getAgendaProgress(facilityId?: string) {
    const where: any = {};
    if (facilityId) where.facilityId = facilityId;

    const [
      departmentLevel,
      facilityLevel,
      corporateLevel,
      committeeSubmitted,
      resolved
    ] = await Promise.all([
      prisma.post.count({ where: { ...where, agendaLevel: 'DEPT_AGENDA' } }),
      prisma.post.count({ where: { ...where, agendaLevel: 'FACILITY_AGENDA' } }),
      prisma.post.count({ where: { ...where, agendaLevel: 'CORP_AGENDA' } }),
      prisma.managementCommitteeAgenda.count({
        where: { status: 'submitted', facilityId }
      }),
      prisma.managementCommitteeAgenda.count({
        where: { status: 'resolved', facilityId }
      })
    ]);

    return {
      departmentLevel,
      facilityLevel,
      corporateLevel,
      committeeSubmitted,
      resolved
    };
  }

  /**
   * 医療システムから職員総数を取得
   */
  private async getEmployeeCount(facilityId?: string): Promise<number> {
    try {
      const params = facilityId ? { facility: facilityId } : {};
      const response = await axios.get(
        `${this.medicalSystemApiUrl}/api/v2/employees/count`,
        {
          headers: {
            Authorization: `Bearer ${this.medicalSystemApiKey}`
          },
          params
        }
      );
      return response.data.filteredCount || response.data.totalCount;
    } catch (error) {
      console.error('Error fetching employee count:', error);
      return 0;
    }
  }

  /**
   * 複数部門からコメントがある投稿数をカウント
   */
  private async getPostsWithCrossDeptEngagement(where: any): Promise<number> {
    const posts = await prisma.post.findMany({
      where,
      include: {
        comments: {
          include: {
            author: { select: { department: true } }
          }
        }
      }
    });

    return posts.filter(post => {
      const departments = new Set(
        post.comments.map(c => c.author?.department).filter(Boolean)
      );
      return departments.size >= 2;
    }).length;
  }
}
```

**実装ファイル**: `src/pages/api/organization-analytics.ts`

```typescript
import type { NextApiRequest, NextApiResponse } from 'next';
import { OrganizationAnalyticsService } from '@/services/OrganizationAnalyticsService';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { facilityId, startDate, endDate } = req.query;

  try {
    const service = new OrganizationAnalyticsService();

    const [organizationHealth, agendaProgress] = await Promise.all([
      service.getOrganizationHealth(
        facilityId as string,
        startDate ? new Date(startDate as string) : undefined,
        endDate ? new Date(endDate as string) : undefined
      ),
      service.getAgendaProgress(facilityId as string)
    ]);

    res.status(200).json({
      organizationHealth,
      agendaProgress,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error fetching organization analytics:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}
```

**チェック項目**:
- [ ] OrganizationAnalyticsService.getOrganizationHealth() が動作する
- [ ] OrganizationAnalyticsService.getAgendaProgress() が動作する
- [ ] GET /api/organization-analytics が動作する
- [ ] 医療システムAPI連携（職員総数取得）が動作する
- [ ] 施設フィルタリングが正しく動作する
- [ ] 日付範囲フィルタリングが正しく動作する
- [ ] パフォーマンス（レスポンスタイム3秒以内）
- [ ] エラーハンドリングが実装されている

**推定工数**: 2.5日
- 集計ロジック実装: 1.5日
- API統合: 0.5日
- テスト・調整: 0.5日

### Phase 3: Webhook実装（3日）

#### 3-1. 医療システム側: Webhook送信機能

**実装ファイル**: `src/services/WebhookService.ts`

```typescript
import axios from 'axios';
import crypto from 'crypto';

export class WebhookService {
  private voiceDriveUrl = process.env.VOICEDRIVE_API_URL;
  private secret = process.env.WEBHOOK_SECRET!;

  /**
   * HMAC-SHA256署名生成
   */
  private generateSignature(payload: string): string {
    return crypto
      .createHmac('sha256', this.secret)
      .update(payload)
      .digest('hex');
  }

  /**
   * Webhook送信
   */
  async sendWebhook(
    endpoint: string,
    eventType: string,
    data: any
  ): Promise<void> {
    const payload = {
      eventType,
      timestamp: new Date().toISOString(),
      data
    };

    const payloadString = JSON.stringify(payload);
    const signature = this.generateSignature(payloadString);

    try {
      await axios.post(
        `${this.voiceDriveUrl}/webhooks/${endpoint}`,
        payload,
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Medical-System-Signature': `sha256=${signature}`
          },
          timeout: 10000
        }
      );

      console.log(`Webhook sent: ${eventType}`);
    } catch (error) {
      console.error(`Error sending webhook ${eventType}:`, error);
      // TODO: リトライキューに追加
      throw error;
    }
  }

  /**
   * 職員入社通知
   */
  async notifyEmployeeCreated(employeeId: string): Promise<void> {
    const employee = await prisma.employee.findUnique({
      where: { employeeId }
    });

    if (!employee) return;

    await this.sendWebhook('employee-created', 'employee.created', {
      employeeId: employee.employeeId,
      name: employee.name,
      email: employee.email,
      department: employee.department,
      facility: employee.facility,
      hireDate: employee.hireDate
    });
  }

  /**
   * 職員情報変更通知
   */
  async notifyEmployeeUpdated(
    employeeId: string,
    changes: any
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.updated', {
      employeeId,
      changes
    });
  }

  /**
   * 部署異動通知
   */
  async notifyDepartmentChanged(
    employeeId: string,
    newDepartment: string,
    previousDepartment: string,
    effectiveDate: Date
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.department_changed', {
      employeeId,
      department: newDepartment,
      previousDepartment,
      effectiveDate: effectiveDate.toISOString()
    });
  }

  /**
   * 権限レベル変更通知
   */
  async notifyPermissionChanged(
    employeeId: string,
    newPermissionLevel: number,
    canPerformLeaderDuty: boolean
  ): Promise<void> {
    await this.sendWebhook('employee-updated', 'employee.permission_changed', {
      employeeId,
      newPermissionLevel,
      canPerformLeaderDuty
    });
  }

  /**
   * 面談結果通知
   */
  async notifyInterviewCompleted(interviewId: string): Promise<void> {
    const interview = await prisma.interview.findUnique({
      where: { id: interviewId },
      include: { employee: true }
    });

    if (!interview) return;

    await this.sendWebhook('interview-completed', 'interview.completed', {
      interviewId: interview.id,
      employeeId: interview.employeeId,
      interviewDate: interview.interviewDate,
      interviewType: interview.interviewType,
      completedAt: interview.completedAt,
      summary: interview.summary,
      keyPoints: interview.keyPoints,
      feedbackToEmployee: interview.feedbackSummary,
      followUpRequired: interview.followUpRequired
    });
  }
}
```

**チェック項目**:
- [ ] HMAC-SHA256署名が正しく生成される
- [ ] Webhook送信が成功する
- [ ] タイムアウトが設定されている
- [ ] エラーハンドリングが実装されている

#### 3-2. VoiceDrive側: Webhook受信エンドポイント

**実装ファイル**: `src/api/routes/webhook.routes.ts`

```typescript
import { Router } from 'express';
import crypto from 'crypto';
import { EmployeeSyncService } from '../../services/EmployeeSyncService';

const router = Router();
const syncService = new EmployeeSyncService();

/**
 * Webhook署名検証ミドルウェア
 */
function verifyWebhookSignature(req: any, res: any, next: any) {
  const signature = req.headers['x-medical-system-signature'];
  const secret = process.env.WEBHOOK_SECRET!;

  if (!signature) {
    return res.status(401).json({ error: 'Missing signature' });
  }

  const payloadString = JSON.stringify(req.body);
  const expectedSignature = 'sha256=' + crypto
    .createHmac('sha256', secret)
    .update(payloadString)
    .digest('hex');

  if (signature !== expectedSignature) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  next();
}

/**
 * POST /api/webhooks/employee-created
 * 職員入社通知
 */
router.post('/employee-created', verifyWebhookSignature, async (req, res) => {
  try {
    const { data } = req.body;
    await syncService.syncEmployee(data.employeeId);
    res.json({ success: true });
  } catch (error) {
    console.error('Error handling employee-created webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * POST /api/webhooks/employee-updated
 * 職員情報変更通知
 */
router.post('/employee-updated', verifyWebhookSignature, async (req, res) => {
  try {
    const { eventType, data } = req.body;

    switch (eventType) {
      case 'employee.department_changed':
        await syncService.syncEmployee(data.employeeId);
        // 投稿可視性再計算
        await recalculatePostVisibility(data.employeeId);
        break;

      case 'employee.permission_changed':
        await syncService.syncEmployee(data.employeeId);
        // アクセス権限再評価
        await reevaluatePermissions(data.employeeId);
        break;

      default:
        await syncService.syncEmployee(data.employeeId);
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Error handling employee-updated webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * POST /api/webhooks/interview-completed
 * 面談結果通知
 */
router.post('/interview-completed', verifyWebhookSignature, async (req, res) => {
  try {
    const { data } = req.body;

    // InterviewResultテーブルにキャッシュ
    await prisma.interviewResult.create({
      data: {
        requestId: data.interviewId,
        interviewId: data.interviewId,
        completedAt: new Date(data.completedAt),
        duration: data.duration || 60,
        summary: data.summary,
        keyPoints: data.keyPoints,
        actionItems: data.actionItems || [],
        followUpRequired: data.followUpRequired,
        followUpDate: data.followUpDate ? new Date(data.followUpDate) : null,
        feedbackToEmployee: data.feedbackToEmployee,
        nextRecommendations: data.nextRecommendations || [],
        status: 'received',
        processedAt: new Date()
      }
    });

    // 職員に通知
    await sendNotificationToEmployee(data.employeeId, {
      title: '面談結果が利用可能です',
      message: '面談の結果とフィードバックが確認できます。'
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error handling interview-completed webhook:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
```

**チェック項目**:
- [ ] Webhook署名検証が動作する
- [ ] employee-created エンドポイントが動作する
- [ ] employee-updated エンドポイントが動作する
- [ ] interview-completed エンドポイントが動作する
- [ ] エラーハンドリングが実装されている

---

### Phase 4: 統合テスト（2日）

#### 4-1. 手動統合テスト

**テストケース1: 職員入社フロー**
```bash
# 医療システム側
curl -X POST http://localhost:8080/api/employees \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "employeeId": "OH-NS-2024-TEST-001",
    "name": "テスト 太郎",
    "email": "test.taro@example.com",
    "department": "内科",
    "facility": "obara-hospital",
    "hireDate": "2024-10-08"
  }'

# VoiceDrive側で確認
curl http://localhost:3001/api/users/OH-NS-2024-TEST-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**期待結果**:
- [ ] 医療システムでEmployee作成成功
- [ ] WebhookがVoiceDriveに送信される
- [ ] VoiceDriveでUser作成成功
- [ ] Userデータが医療システムと一致

**テストケース2: 部署異動フロー**
```bash
# 医療システム側
curl -X PATCH http://localhost:8080/api/employees/OH-NS-2024-TEST-001/department \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "newDepartment": "外科",
    "effectiveDate": "2024-11-01"
  }'

# VoiceDrive側で確認
curl http://localhost:3001/api/users/OH-NS-2024-TEST-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**期待結果**:
- [ ] 医療システムで部署異動処理成功
- [ ] AssignmentHistory作成
- [ ] WebhookがVoiceDriveに送信される
- [ ] VoiceDriveのUser.department更新
- [ ] 投稿可視性が再計算される

**テストケース3: 面談結果通知フロー**
```bash
# 医療システム側（面談完了）
curl -X POST http://localhost:8080/api/interviews/INT-001/complete \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d '{
    "summary": "前向きな姿勢が見られる",
    "feedbackToEmployee": "引き続き頑張ってください"
  }'

# VoiceDrive側で確認
curl http://localhost:3001/api/interview-results/INT-001 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

**期待結果**:
- [ ] 医療システムで面談記録作成
- [ ] AI分析実行
- [ ] WebhookがVoiceDriveに送信される
- [ ] VoiceDriveのInterviewResult作成
- [ ] 職員に通知が送信される

#### 4-2. 自動統合テスト

**実装ファイル**: `tests/integration/employee-sync.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import axios from 'axios';

describe('Employee Sync Integration Tests', () => {
  const medicalApiUrl = 'http://localhost:8080/api';
  const voiceDriveApiUrl = 'http://localhost:3001/api';
  const testEmployeeId = `TEST-${Date.now()}`;

  beforeAll(async () => {
    // テストデータセットアップ
  });

  afterAll(async () => {
    // テストデータクリーンアップ
  });

  it('should sync employee on creation', async () => {
    // 医療システムで職員作成
    const createResponse = await axios.post(
      `${medicalApiUrl}/employees`,
      {
        employeeId: testEmployeeId,
        name: 'テスト 太郎',
        email: `${testEmployeeId}@example.com`,
        department: '内科'
      },
      { headers: { Authorization: `Bearer ${process.env.API_KEY}` } }
    );

    expect(createResponse.status).toBe(201);

    // 5秒待機（Webhook処理）
    await new Promise(resolve => setTimeout(resolve, 5000));

    // VoiceDriveで確認
    const voiceDriveResponse = await axios.get(
      `${voiceDriveApiUrl}/users/${testEmployeeId}`,
      { headers: { Authorization: `Bearer ${process.env.JWT_TOKEN}` } }
    );

    expect(voiceDriveResponse.status).toBe(200);
    expect(voiceDriveResponse.data.employeeId).toBe(testEmployeeId);
    expect(voiceDriveResponse.data.name).toBe('テスト 太郎');
  });

  it('should sync department change', async () => {
    // 部署異動
    await axios.patch(
      `${medicalApiUrl}/employees/${testEmployeeId}/department`,
      { newDepartment: '外科' },
      { headers: { Authorization: `Bearer ${process.env.API_KEY}` } }
    );

    await new Promise(resolve => setTimeout(resolve, 5000));

    // VoiceDriveで確認
    const response = await axios.get(
      `${voiceDriveApiUrl}/users/${testEmployeeId}`,
      { headers: { Authorization: `Bearer ${process.env.JWT_TOKEN}` } }
    );

    expect(response.data.department).toBe('外科');
  });
});
```

**チェック項目**:
- [ ] 統合テストが全て通過する
- [ ] CI/CDパイプラインに統合されている

---

### Phase 5: 監視・ロギング（1日）

#### 5-1. ロギング実装

**実装ファイル**: `src/utils/logger.ts`

```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// 統合ログ用
export const integrationLogger = logger.child({ component: 'integration' });
```

**使用例**:
```typescript
integrationLogger.info('Employee synced', {
  employeeId: 'OH-NS-2024-001',
  action: 'sync',
  source: 'webhook'
});

integrationLogger.error('Webhook failed', {
  eventType: 'employee.created',
  error: error.message
});
```

#### 5-2. 監視ダッシュボード

**メトリクス**:
- Webhook成功率
- API応答時間
- 同期エラー率
- データ整合性チェック結果

**アラート設定**:
- Webhook失敗率 > 1%
- API応答時間 > 1秒
- データ不整合検出時

---

## 📋 チェックリスト

### 環境準備
- [ ] MySQL環境構築完了（AWS Lightsail）
- [ ] VoiceDrive DB作成・マイグレーション完了
- [ ] 医療システムDB作成・マイグレーション完了
- [ ] 環境変数設定完了（両システム）
- [ ] ネットワーク接続確認完了

### API実装
- [ ] 医療システム: GET /api/employees/:id 実装
- [ ] 医療システム: GET /api/employees 実装
- [ ] VoiceDrive: EmployeeSyncService実装
- [ ] 認証・認可実装
- [ ] エラーハンドリング実装
- [ ] レート制限実装

### Webhook実装
- [ ] 医療システム: WebhookService実装
- [ ] 医療システム: 署名生成実装
- [ ] VoiceDrive: Webhook受信エンドポイント実装
- [ ] VoiceDrive: 署名検証実装
- [ ] リトライロジック実装
- [ ] エラーログ記録実装

### テスト
- [ ] 単体テスト実装・通過
- [ ] 統合テスト実装・通過
- [ ] 手動テスト実施・完了
- [ ] パフォーマンステスト実施
- [ ] セキュリティテスト実施

### ドキュメント
- [ ] API仕様書作成（OpenAPI 3.0）
- [ ] Webhook仕様書作成
- [ ] 運用手順書作成
- [ ] トラブルシューティングガイド作成

### 監視・運用
- [ ] ロギング実装
- [ ] 監視ダッシュボード構築
- [ ] アラート設定
- [ ] 障害対応手順書作成

---

## 🚨 想定されるリスクと対策

### リスク1: Webhook配信失敗

**原因**:
- ネットワーク障害
- VoiceDriveサーバーダウン
- タイムアウト

**対策**:
- リトライキュー実装（Redis使用）
- 最大3回リトライ
- 失敗時はアラート通知
- 手動再送機能実装

### リスク2: データ不整合

**原因**:
- 同期処理の失敗
- 競合状態（race condition）
- 部分的な更新失敗

**対策**:
- 日次データ整合性チェックバッチ
- トランザクション管理
- 楽観的ロック（optimistic locking）
- 不整合検出時の自動修正

### リスク3: パフォーマンス低下

**原因**:
- 大量データ同期
- API呼び出しの増加
- データベースクエリの非効率

**対策**:
- バッチ同期の最適化
- キャッシュ戦略（Redis）
- データベースインデックス最適化
- 非同期処理の活用

---

## 📊 成功指標（KPI）

### Phase 1-3完了時
- [ ] 全APIエンドポイントが正常動作（100%）
- [ ] Webhook成功率 > 95%
- [ ] API応答時間 < 500ms（P95）
- [ ] 統合テスト合格率 100%

### Phase 4-5完了時
- [ ] データ同期精度 > 99.9%
- [ ] Webhook成功率 > 99%
- [ ] システム可用性 > 99.5%
- [ ] エラー率 < 0.1%

---

## 📞 連絡先・リソース

### ドキュメント
- [データ管理責任分界点定義書](./データ管理責任分界点定義書_20251008.md)
- [MySQL_Migration_Guide.md](../../docs/MySQL_Migration_Guide.md)
- [VoiceDrive_MySQL_Migration_Request_20251008.md](./VoiceDrive_MySQL_Migration_Request_20251008.md)

### 技術スタック
- **DB**: MySQL 8.0
- **ORM**: Prisma
- **API**: Express.js (Node.js)
- **認証**: JWT + APIキー
- **Webhook**: HMAC-SHA256署名
- **監視**: Winston (ログ), Prometheus (メトリクス)

### Git Commits（参照用）
- `74fb6cc`: validateEnv.ts作成
- `f9db560`: Prisma schema MySQL対応
- `0b17d07`: MySQL_Migration_Guide.md作成
- `3be6b51`: 完了報告書作成
- `a89ac48`: 医療チームへの依頼文書作成

---

## 🎯 次のアクション

1. **MySQL環境構築完了を待つ**
   - 医療システムチームに進捗確認
   - AWS Lightsail構築状況確認

2. **構築完了後、即座にPhase 1開始**
   - このドキュメントに従って作業
   - 各Phaseごとにチェックリスト確認
   - 問題発生時は即座にエスカレーション

3. **定例会議で進捗報告**
   - 毎週月曜 10:00-11:00
   - 統合作業の進捗共有
   - 課題・リスクの共有

---

**文書終了**

最終更新: 2025年10月10日
バージョン: 1.1（OrganizationAnalytics要件追加）
次回レビュー: DB構築完了後
