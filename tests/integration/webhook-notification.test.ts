/**
 * VoiceDrive WebhookÈÄöÁü•APIÁµ±Âêà„ÉÜ„Çπ„Éà
 *
 * ËÅ∑Âì°„Ç´„É´„ÉÜ„Ç∑„Çπ„ÉÜ„É†„Åã„Çâ„ÅÆAnalytics„Éê„ÉÉ„ÉÅÂá¶ÁêÜÈÄöÁü•Âèó‰ø°„ÉÜ„Çπ„Éà
 * ‰ΩúÊàêÊó•: 2025Âπ¥10Êúà10Êó•
 */

import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import axios, { AxiosInstance, AxiosError } from 'axios';
import crypto from 'crypto';

const BASE_URL = 'http://localhost:4000';
const WEBHOOK_URL = `${BASE_URL}/api/webhook/analytics-notification`;

// HMACÁΩ≤Âêç„Ç∑„Éº„ÇØ„É¨„ÉÉ„ÉàÔºà.env.integration-test„Å®Âêå„ÅòÔºâ
const WEBHOOK_SECRET = 'webhook-notification-secret-2025';

/**
 * HMACÁΩ≤ÂêçÁîüÊàê
 */
function generateHMACSignature(payload: string, timestamp: string): string {
  return crypto.createHmac('sha256', WEBHOOK_SECRET)
    .update(payload + timestamp)
    .digest('hex');
}

/**
 * „ÉÜ„Çπ„ÉàÁî®ÈÄöÁü•„Éá„Éº„Çø‰ΩúÊàê
 */
function createTestNotification(overrides?: any) {
  const timestamp = new Date().toISOString();
  const notification = {
    notificationId: `test-${Date.now()}`,
    timestamp,
    accountLevel: 99,
    type: 'success',
    title: 'Analytics„Éê„ÉÉ„ÉÅÂá¶ÁêÜÂÆå‰∫Ü',
    message: 'LLMÂàÜÊûê„ÅåÊ≠£Â∏∏„Å´ÂÆå‰∫Ü„Åó„Åæ„Åó„Åü',
    details: {
      processedRecords: 150,
      startTime: '2025-10-10T02:00:00.000Z',
      endTime: '2025-10-10T02:05:30.000Z',
      processingDuration: 330000
    },
    ...overrides
  };

  return { notification, timestamp };
}

describe('VoiceDrive WebhookÈÄöÁü•APIÁµ±Âêà„ÉÜ„Çπ„Éà', () => {
  beforeAll(async () => {
    console.log('üöÄ WebhookÈÄöÁü•Áµ±Âêà„ÉÜ„Çπ„ÉàÈñãÂßã');
    console.log(`üìç WebhookURL: ${WEBHOOK_URL}`);
    console.log(`üîê HMACÁΩ≤ÂêçÊ§úË®º: ÊúâÂäπ`);
  });

  afterAll(() => {
    console.log('‚úÖ WebhookÈÄöÁü•Áµ±Âêà„ÉÜ„Çπ„ÉàÂÆå‰∫Ü');
  });

  /**
   * Phase 1: Ê≠£Â∏∏Á≥ª„ÉÜ„Çπ„Éà
   */
  describe('Phase 1: Ê≠£Â∏∏Á≥ª„ÉÜ„Çπ„Éà', () => {
    it('ÊàêÂäüÈÄöÁü•Ôºàtype: successÔºâ', async () => {
      const { notification, timestamp } = createTestNotification();
      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      const response = await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.message).toBe('ÈÄöÁü•„ÇíÂèó‰ø°„Åó„Åæ„Åó„Åü');
      expect(response.data.notificationId).toBe(notification.notificationId);
      expect(response.data.receivedAt).toBeDefined();

      console.log('‚úÖ ÊàêÂäüÈÄöÁü•„ÉÜ„Çπ„ÉàÊàêÂäü');
      console.log(`   ÈÄöÁü•ID: ${response.data.notificationId}`);
    });

    it('„Ç®„É©„ÉºÈÄöÁü•Ôºàtype: errorÔºâ', async () => {
      const { notification, timestamp } = createTestNotification({
        type: 'error',
        title: 'Analytics„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„Ç®„É©„Éº',
        message: 'LLMÂàÜÊûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü',
        details: {
          errorCode: 'LLM_CONNECTION_ERROR',
          errorMessage: 'OpenAI API„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì',
          failedAt: '2025-10-10T02:03:15.000Z',
          retryCount: 3
        }
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      const response = await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);

      console.log('‚úÖ „Ç®„É©„ÉºÈÄöÁü•„ÉÜ„Çπ„ÉàÊàêÂäü');
    });

    it('Ë≠¶ÂëäÈÄöÁü•Ôºàtype: warningÔºâ', async () => {
      const { notification, timestamp } = createTestNotification({
        type: 'warning',
        title: '„Éá„Éº„ÇøÈáèË≠¶Âëä',
        message: 'ÂàÜÊûêÂØæË±°„Éá„Éº„Çø„Åå‰∫àÊÉ≥„Çà„ÇäÂ∞ë„Å™„ÅÑ„Åß„Åô'
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      const response = await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);

      console.log('‚úÖ Ë≠¶ÂëäÈÄöÁü•„ÉÜ„Çπ„ÉàÊàêÂäü');
    });

    it('ÊÉÖÂ†±ÈÄöÁü•Ôºàtype: infoÔºâ', async () => {
      const { notification, timestamp } = createTestNotification({
        type: 'info',
        title: '„Éê„ÉÉ„ÉÅÂá¶ÁêÜÈñãÂßã',
        message: 'Analytics„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü'
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      const response = await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);

      console.log('‚úÖ ÊÉÖÂ†±ÈÄöÁü•„ÉÜ„Çπ„ÉàÊàêÂäü');
    });
  });

  /**
   * Phase 2: „Ç®„É©„Éº„Ç±„Éº„Çπ„ÉÜ„Çπ„ÉàÔºà„Çª„Ç≠„É•„É™„ÉÜ„Ç£Ôºâ
   */
  describe('Phase 2: „Ç®„É©„Éº„Ç±„Éº„Çπ„ÉÜ„Çπ„ÉàÔºà„Çª„Ç≠„É•„É™„ÉÜ„Ç£Ôºâ', () => {
    it('„Ç®„É©„Éº: X-Signature„Éò„ÉÉ„ÉÄ„ÉºÁÑ°„Åó', async () => {
      const { notification, timestamp } = createTestNotification();

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Timestamp': timestamp
            // X-SignatureÁÑ°„Åó
          }
        });
        expect(true).toBe(false); // „Åì„Åì„Å´„ÅØÂà∞ÈÅî„Åó„Å™„ÅÑ„ÅØ„Åö
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(400);
        expect((axiosError.response?.data as any).error.code).toBe('MISSING_SIGNATURE');

        console.log('‚úÖ X-Signature„Éò„ÉÉ„ÉÄ„ÉºÁÑ°„Åó„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });

    it('„Ç®„É©„Éº: X-Timestamp„Éò„ÉÉ„ÉÄ„ÉºÁÑ°„Åó', async () => {
      const { notification, timestamp } = createTestNotification();
      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature
            // X-TimestampÁÑ°„Åó
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(400);
        expect((axiosError.response?.data as any).error.code).toBe('MISSING_TIMESTAMP');

        console.log('‚úÖ X-Timestamp„Éò„ÉÉ„ÉÄ„ÉºÁÑ°„Åó„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });

    it('„Ç®„É©„Éº: ÁÑ°Âäπ„Å™HMACÁΩ≤Âêç', async () => {
      const { notification, timestamp } = createTestNotification();
      const invalidSignature = 'invalid-signature-12345';

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': invalidSignature,
            'X-Timestamp': timestamp
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(401);
        expect((axiosError.response?.data as any).error.code).toBe('INVALID_SIGNATURE');

        console.log('‚úÖ ÁÑ°Âäπ„Å™HMACÁΩ≤Âêç„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });

    it('„Ç®„É©„Éº: „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÅåÂè§„Åô„Åé„ÇãÔºà6ÂàÜÂâçÔºâ', async () => {
      const { notification } = createTestNotification();
      const oldTimestamp = new Date(Date.now() - 6 * 60 * 1000).toISOString(); // 6ÂàÜÂâç
      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, oldTimestamp);

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': oldTimestamp
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(401);
        expect((axiosError.response?.data as any).error.code).toBe('INVALID_SIGNATURE');

        console.log('‚úÖ „Çø„Ç§„É†„Çπ„Çø„É≥„ÉóÊúüÈôêÂàá„Çå„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });
  });

  /**
   * Phase 3: „Ç®„É©„Éº„Ç±„Éº„Çπ„ÉÜ„Çπ„ÉàÔºà„Éê„É™„Éá„Éº„Ç∑„Éß„É≥Ôºâ
   */
  describe('Phase 3: „Ç®„É©„Éº„Ç±„Éº„Çπ„ÉÜ„Çπ„ÉàÔºà„Éê„É™„Éá„Éº„Ç∑„Éß„É≥Ôºâ', () => {
    it('„Ç®„É©„Éº: notificationIdÁÑ°„Åó', async () => {
      const { notification, timestamp } = createTestNotification();
      delete (notification as any).notificationId;

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': timestamp
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(400);
        expect((axiosError.response?.data as any).error.code).toBe('MISSING_NOTIFICATION_ID');

        console.log('‚úÖ notificationIdÁÑ°„Åó„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });

    it('„Ç®„É©„Éº: accountLevel„Åå99„Åß„ÅØ„Å™„ÅÑ', async () => {
      const { notification, timestamp } = createTestNotification({
        accountLevel: 1 // 99„Åß„ÅØ„Å™„ÅÑ
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': timestamp
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(403);
        expect((axiosError.response?.data as any).error.code).toBe('INVALID_ACCOUNT_LEVEL');

        console.log('‚úÖ accountLevelÊ§úË®º„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });

    it('„Ç®„É©„Éº: ÁÑ°Âäπ„Å™ÈÄöÁü•„Çø„Ç§„Éó', async () => {
      const { notification, timestamp } = createTestNotification({
        type: 'invalid-type'
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      try {
        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': timestamp
          }
        });
        expect(true).toBe(false);
      } catch (error) {
        const axiosError = error as AxiosError;
        expect(axiosError.response?.status).toBe(400);
        expect((axiosError.response?.data as any).error.code).toBe('INVALID_NOTIFICATION_TYPE');

        console.log('‚úÖ ÁÑ°Âäπ„Å™ÈÄöÁü•„Çø„Ç§„Éó„Ç®„É©„Éº„ÉÜ„Çπ„ÉàÊàêÂäü');
      }
    });
  });

  /**
   * Phase 4: „Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠òÁ¢∫Ë™ç„ÉÜ„Çπ„Éà
   */
  describe('Phase 4: „Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠òÁ¢∫Ë™ç„ÉÜ„Çπ„Éà', () => {
    it('ÈÄöÁü•„Åå„Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò„Åï„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç', async () => {
      const { notification, timestamp } = createTestNotification({
        notificationId: `db-test-${Date.now()}`,
        title: '„Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠ò„ÉÜ„Çπ„Éà'
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      // ÈÄöÁü•„ÇíÈÄÅ‰ø°
      const response = await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);

      // „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„ÇâÈÄöÁü•„ÇíÂèñÂæó
      const getResponse = await axios.get(`${BASE_URL}/api/webhook/notifications`, {
        params: {
          limit: 1
        }
      });

      expect(getResponse.status).toBe(200);
      expect(getResponse.data.success).toBe(true);
      expect(getResponse.data.data.length).toBeGreaterThan(0);

      // ÊúÄÊñ∞„ÅÆÈÄöÁü•„Åå‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
      const savedNotification = getResponse.data.data[0];
      expect(savedNotification.notificationId).toBe(notification.notificationId);
      expect(savedNotification.type).toBe(notification.type);
      expect(savedNotification.title).toBe(notification.title);
      expect(savedNotification.message).toBe(notification.message);
      expect(savedNotification.accountLevel).toBe(notification.accountLevel);
      expect(savedNotification.read).toBe(false);

      console.log('‚úÖ „Éá„Éº„Çø„Éô„Éº„Çπ‰øùÂ≠òÁ¢∫Ë™ç„ÉÜ„Çπ„ÉàÊàêÂäü');
      console.log(`   ‰øùÂ≠ò„Åï„Çå„ÅüÈÄöÁü•ID: ${savedNotification.id}`);
      console.log(`   notificationId: ${savedNotification.notificationId}`);
    });

    it('Ë§áÊï∞ÈÄöÁü•„ÅÆÂèñÂæó„Å®„Éï„Ç£„É´„Çø„É™„É≥„Ç∞', async () => {
      // Áï∞„Å™„Çã„Çø„Ç§„Éó„ÅÆÈÄöÁü•„Çí3‰ª∂ÈÄÅ‰ø°
      const types = ['success', 'error', 'warning'];
      for (const type of types) {
        const { notification, timestamp } = createTestNotification({
          notificationId: `filter-test-${type}-${Date.now()}`,
          type,
          title: `„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÉÜ„Çπ„Éà - ${type}`
        });

        const payload = JSON.stringify(notification);
        const signature = generateHMACSignature(payload, timestamp);

        await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': timestamp
          }
        });
      }

      // successÈÄöÁü•„ÅÆ„Åø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      const getResponse = await axios.get(`${BASE_URL}/api/webhook/notifications`, {
        params: {
          type: 'success',
          limit: 10
        }
      });

      expect(getResponse.status).toBe(200);
      expect(getResponse.data.success).toBe(true);

      // „Åô„Åπ„Å¶successÈÄöÁü•„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
      getResponse.data.data.forEach((notification: any) => {
        expect(notification.type).toBe('success');
      });

      console.log('‚úÖ „Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÉÜ„Çπ„ÉàÊàêÂäü');
      console.log(`   successÈÄöÁü•‰ª∂Êï∞: ${getResponse.data.data.length}`);
    });

    it('ÈÄöÁü•„ÅÆÊó¢Ë™≠Êõ¥Êñ∞', async () => {
      // ÈÄöÁü•„Çí1‰ª∂ÈÄÅ‰ø°
      const { notification, timestamp } = createTestNotification({
        notificationId: `read-test-${Date.now()}`,
        title: 'Êó¢Ë™≠„ÉÜ„Çπ„Éà'
      });

      const payload = JSON.stringify(notification);
      const signature = generateHMACSignature(payload, timestamp);

      await axios.post(WEBHOOK_URL, notification, {
        headers: {
          'Content-Type': 'application/json',
          'X-Signature': signature,
          'X-Timestamp': timestamp
        }
      });

      // ÊúÄÊñ∞„ÅÆÈÄöÁü•„ÇíÂèñÂæó
      const getResponse = await axios.get(`${BASE_URL}/api/webhook/notifications`, {
        params: { limit: 1 }
      });

      const savedNotification = getResponse.data.data[0];
      expect(savedNotification.read).toBe(false);

      // Êó¢Ë™≠„Å´„Åô„Çã
      const patchResponse = await axios.patch(
        `${BASE_URL}/api/webhook/notifications/${savedNotification.id}/read`
      );

      expect(patchResponse.status).toBe(200);
      expect(patchResponse.data.success).toBe(true);
      expect(patchResponse.data.data.read).toBe(true);
      expect(patchResponse.data.data.readAt).toBeDefined();

      console.log('‚úÖ Êó¢Ë™≠Êõ¥Êñ∞„ÉÜ„Çπ„ÉàÊàêÂäü');
      console.log(`   ÈÄöÁü•ID: ${savedNotification.id}`);
      console.log(`   Êó¢Ë™≠ÊôÇÂàª: ${patchResponse.data.data.readAt}`);
    });
  });

  /**
   * Phase 5: „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
   */
  describe('Phase 5: „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà', () => {
    it('ÈÄ£Á∂ö5‰ª∂„ÅÆÈÄöÁü•ÈÄÅ‰ø°', async () => {
      const startTime = Date.now();
      const results: any[] = [];

      for (let i = 0; i < 5; i++) {
        const { notification, timestamp } = createTestNotification({
          notificationId: `perf-test-${i}-${Date.now()}`,
          title: `„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„ÉàÈÄöÁü• ${i + 1}/5`
        });

        const payload = JSON.stringify(notification);
        const signature = generateHMACSignature(payload, timestamp);

        const response = await axios.post(WEBHOOK_URL, notification, {
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': signature,
            'X-Timestamp': timestamp
          }
        });

        results.push({
          status: response.status,
          notificationId: response.data.notificationId
        });
      }

      const endTime = Date.now();
      const totalTime = endTime - startTime;
      const avgTime = totalTime / 5;

      expect(results.length).toBe(5);
      results.forEach(result => {
        expect(result.status).toBe(200);
      });

      console.log('‚úÖ ÈÄ£Á∂ö5‰ª∂ÈÄöÁü•ÈÄÅ‰ø°ÊàêÂäü');
      console.log(`   Á∑èÂá¶ÁêÜÊôÇÈñì: ${totalTime}ms`);
      console.log(`   Âπ≥ÂùáÂá¶ÁêÜÊôÇÈñì: ${avgTime.toFixed(2)}ms/‰ª∂`);
    });
  });
});
