# 医療職員管理システム側 コンプライアンス窓口実装依頼書

## 📅 作成日：2025年9月24日
## 📌 文書番号：MED-COMP-REQ-001
## 🎯 重要度：最高優先度
## 📨 宛先：医療職員管理システム開発チーム

---

## 1. 依頼概要

### 1.1 背景と目的

医療法人厚生会（小原病院）のコンプライアンス体制強化のため、VoiceDriveシステムと連携したデジタルコンプライアンス窓口機能の実装を依頼いたします。本機能により、24時間365日の匿名通報受付と適切な調査・対応プロセスの確立を実現します。

### 1.2 期待される成果

- ハラスメント・不正行為の早期発見と対応
- 公益通報者保護法に準拠した通報者保護
- 調査プロセスの透明性と公正性の確保
- 小原病院規定に完全準拠した運用体制

### 1.3 納期

- **Phase 1（必須機能）**：2025年10月7日
- **Phase 2（拡張機能）**：2025年10月21日
- **本番稼働開始**：2025年11月1日

---

## 2. システム要件

### 2.1 技術要件

```yaml
必須要件:
  プラットフォーム:
    - Node.js: v18.0以上
    - TypeScript: v5.0以上

  データベース:
    - MySQL 8.0以上 または PostgreSQL 14以上
    - 暗号化対応（Transparent Data Encryption推奨）

  セキュリティ:
    - TLS 1.3による通信暗号化
    - AES-256-GCMによるデータ暗号化
    - JWT (RS256)による認証

  パフォーマンス:
    - API応答時間: 200ms以内（99%tile）
    - 同時接続数: 1000以上
    - 可用性: 99.9%以上

推奨構成:
  - フレームワーク: Express.js または Fastify
  - ORM: Prisma または TypeORM
  - キューシステム: Redis + Bull Queue
  - ロギング: Winston + Elasticsearch
  - モニタリング: Prometheus + Grafana
```

### 2.2 機能要件

#### 2.2.1 通報受付機能

**必須実装項目：**

1. **VoiceDriveからの通報受信API**
   - 暗号化されたペイロードの受信
   - チェックサム検証
   - 受信確認応答（ケース番号発行）

2. **通報カテゴリ管理**
   - ハラスメント（パワー、セクシャル、マタニティ）
   - 医療法令違反
   - 診療報酬不正請求
   - 個人情報漏洩
   - 研究不正行為

3. **緊急度判定と自動振り分け**
   - Critical：即時対応（1時間以内）
   - High：当日対応
   - Medium：3営業日以内
   - Low：1週間以内

#### 2.2.2 調査管理機能

1. **担当者割り当て**
   - 事務長、看護部長への自動通知
   - カテゴリ別の担当者設定
   - エスカレーション機能

2. **調査プロセス管理**
   - ヒアリング記録
   - 証拠管理
   - タイムライン記録

3. **委員会連携**
   - ハラスメント対策委員会
   - 懲戒委員会
   - 労働衛生委員会

#### 2.2.3 情報開示制御

**3段階の情報開示レベル：**

1. **第1段階（匿名維持）**
   - カテゴリ、内容、緊急度のみ
   - 個人情報は完全秘匿

2. **第2段階（限定開示）**
   - 部署情報、時期の詳細
   - 調査責任者のみ実名アクセス可

3. **第3段階（必要最小限開示）**
   - 懲戒処分に必要な全情報
   - アクセスログ完全記録

---

## 3. データベース設計

### 3.1 必須テーブル構造

```sql
-- 1. コンプライアンス通報マスターテーブル
CREATE TABLE compliance_reports (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  case_number VARCHAR(20) UNIQUE NOT NULL COMMENT 'MED-2025-XXXX形式',
  voicedrive_report_id VARCHAR(50) UNIQUE NOT NULL,
  anonymous_id VARCHAR(20) UNIQUE NOT NULL,

  -- 通報者情報（暗号化必須）
  reporter_encrypted TEXT COMMENT 'AES-256-GCM暗号化',
  reporter_disclosure_level ENUM('full_anonymous', 'conditional', 'disclosed') NOT NULL,
  reporter_consent_json TEXT,

  -- カテゴリと緊急度
  category VARCHAR(50) NOT NULL,
  subcategory VARCHAR(50),
  severity ENUM('low', 'medium', 'high', 'critical') NOT NULL,

  -- 事案内容（暗号化必須）
  incident_encrypted TEXT NOT NULL COMMENT 'AES-256-GCM暗号化',
  evidence_metadata_json TEXT,

  -- ステータス管理
  status ENUM('received', 'triaging', 'investigating', 'escalated', 'resolved', 'closed') NOT NULL DEFAULT 'received',
  current_handler VARCHAR(100),
  assigned_at TIMESTAMP,

  -- タイムスタンプ
  received_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  resolved_at TIMESTAMP,
  closed_at TIMESTAMP,

  -- セキュリティ
  transfer_checksum VARCHAR(64) NOT NULL,
  encryption_key_id VARCHAR(50) NOT NULL,

  INDEX idx_case_number (case_number),
  INDEX idx_anonymous_id (anonymous_id),
  INDEX idx_status_severity (status, severity),
  INDEX idx_received_at (received_at),
  INDEX idx_category (category)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 2. アクセス制御テーブル
CREATE TABLE compliance_access_control (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  report_id BIGINT NOT NULL,
  user_id VARCHAR(50) NOT NULL,
  user_role VARCHAR(50) NOT NULL,
  access_level ENUM('view_summary', 'view_details', 'view_identity', 'edit', 'admin') NOT NULL,

  -- 承認情報
  granted_by VARCHAR(50) NOT NULL,
  granted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  grant_reason TEXT,
  expires_at TIMESTAMP,

  -- 取り消し情報
  revoked_at TIMESTAMP,
  revoked_by VARCHAR(50),
  revoke_reason TEXT,

  FOREIGN KEY (report_id) REFERENCES compliance_reports(id) ON DELETE CASCADE,
  UNIQUE KEY uk_report_user (report_id, user_id),
  INDEX idx_user_id (user_id),
  INDEX idx_expires_at (expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 3. 調査記録テーブル
CREATE TABLE compliance_investigations (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  report_id BIGINT NOT NULL,
  investigator_id VARCHAR(50) NOT NULL,
  investigator_name VARCHAR(100) NOT NULL,
  investigator_role VARCHAR(50) NOT NULL,

  -- 調査内容（暗号化必須）
  findings_encrypted TEXT COMMENT '調査結果',
  evidence_collected_json TEXT COMMENT '収集証拠リスト',
  witness_statements_encrypted TEXT COMMENT '証人証言',

  -- 判定結果
  determination ENUM('substantiated', 'unsubstantiated', 'inconclusive', 'pending') DEFAULT 'pending',
  determination_date TIMESTAMP,
  recommended_action TEXT,

  -- 委員会連携
  referred_to_committee BOOLEAN DEFAULT FALSE,
  committee_type VARCHAR(50),
  committee_decision TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (report_id) REFERENCES compliance_reports(id) ON DELETE CASCADE,
  INDEX idx_investigator (investigator_id),
  INDEX idx_determination (determination)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 4. 監査ログテーブル（改ざん防止）
CREATE TABLE compliance_audit_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  report_id BIGINT,
  user_id VARCHAR(50) NOT NULL,
  user_name VARCHAR(100),
  user_role VARCHAR(50) NOT NULL,

  -- アクション詳細
  action VARCHAR(100) NOT NULL,
  action_detail TEXT,
  data_before TEXT COMMENT '変更前データ',
  data_after TEXT COMMENT '変更後データ',

  -- アクセス情報
  ip_address VARCHAR(45) NOT NULL,
  user_agent TEXT,
  session_id VARCHAR(100),

  -- ブロックチェーン風の連鎖（改ざん防止）
  previous_hash VARCHAR(64),
  current_hash VARCHAR(64) NOT NULL,

  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_report_id (report_id),
  INDEX idx_user_id (user_id),
  INDEX idx_timestamp (timestamp),
  INDEX idx_action (action)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 5. 通知管理テーブル
CREATE TABLE compliance_notifications (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  report_id BIGINT NOT NULL,

  -- 通知先
  recipient_id VARCHAR(50) NOT NULL,
  recipient_name VARCHAR(100),
  recipient_role VARCHAR(50) NOT NULL,
  recipient_email VARCHAR(255),

  -- 通知内容
  notification_type ENUM('new_report', 'status_change', 'action_required', 'escalation', 'resolution') NOT NULL,
  priority ENUM('low', 'normal', 'high', 'urgent') NOT NULL DEFAULT 'normal',
  subject VARCHAR(255) NOT NULL,
  content_json TEXT NOT NULL,

  -- 送信状態
  status ENUM('pending', 'sent', 'failed', 'cancelled') DEFAULT 'pending',
  sent_at TIMESTAMP,
  read_at TIMESTAMP,
  error_message TEXT,
  retry_count INT DEFAULT 0,

  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  scheduled_for TIMESTAMP,

  FOREIGN KEY (report_id) REFERENCES compliance_reports(id) ON DELETE CASCADE,
  INDEX idx_recipient (recipient_id),
  INDEX idx_status_priority (status, priority),
  INDEX idx_scheduled (scheduled_for)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 6. 委員会管理テーブル
CREATE TABLE compliance_committees (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  report_id BIGINT NOT NULL,
  committee_type ENUM('harassment', 'disciplinary', 'health_safety') NOT NULL,

  -- 会議情報
  meeting_date TIMESTAMP,
  meeting_minutes_encrypted TEXT,
  attendees_json TEXT,

  -- 決定事項
  decision TEXT,
  decision_date TIMESTAMP,
  action_items_json TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (report_id) REFERENCES compliance_reports(id) ON DELETE CASCADE,
  INDEX idx_committee_type (committee_type),
  INDEX idx_meeting_date (meeting_date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

## 4. API仕様

### 4.1 通報受信API

#### エンドポイント: `POST /api/v3/compliance/receive`

**リクエスト仕様：**

```typescript
interface ReceiveRequest {
  headers: {
    'Content-Type': 'application/json';
    'Authorization': `Bearer ${token}`;
    'X-Request-ID': string;  // UUID v4
    'X-Checksum': string;     // SHA-256
    'X-Timestamp': string;    // ISO 8601
  };

  body: {
    version: '1.0';
    source: 'voicedrive';
    payload: {
      encrypted: string;      // AES-256-GCM暗号化データ
      iv: string;            // 初期化ベクトル
      authTag: string;       // 認証タグ
    };
    checksum: string;        // ペイロードのSHA-256
    metadata: {
      reportId: string;
      anonymousId: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      requiresImmediateAction: boolean;
      category: string;
    };
  };
}
```

**レスポンス仕様：**

```typescript
// 成功時 (200 OK)
interface SuccessResponse {
  success: true;
  caseNumber: string;         // MED-2025-XXXX
  acknowledgementId: string;   // UUID v4
  receivedAt: string;          // ISO 8601
  message: string;
  estimatedResponseTime: {
    value: number;
    unit: 'hours' | 'days';
  };
}

// エラー時 (400/401/403/500)
interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
  };
  requestId: string;
  timestamp: string;
}
```

**実装サンプル：**

```typescript
// src/controllers/ComplianceReceiveController.ts
import { Request, Response } from 'express';
import { ComplianceService } from '../services/ComplianceService';
import { ValidationService } from '../services/ValidationService';
import { CryptoService } from '../services/CryptoService';

export class ComplianceReceiveController {
  constructor(
    private complianceService: ComplianceService,
    private validationService: ValidationService,
    private cryptoService: CryptoService
  ) {}

  async receive(req: Request, res: Response): Promise<void> {
    const requestId = req.headers['x-request-id'] as string;

    try {
      // 1. リクエスト検証
      await this.validationService.validateComplianceRequest(req);

      // 2. チェックサム確認
      const checksumValid = await this.cryptoService.verifyChecksum(
        req.body.payload,
        req.body.checksum
      );

      if (!checksumValid) {
        throw new ValidationError('Checksum verification failed');
      }

      // 3. ペイロード復号化
      const decrypted = await this.cryptoService.decrypt(req.body.payload);
      const reportData = JSON.parse(decrypted);

      // 4. ケース番号生成
      const caseNumber = await this.complianceService.generateCaseNumber();

      // 5. データベース保存
      const report = await this.complianceService.createReport({
        caseNumber,
        voicedriveReportId: reportData.reportId,
        anonymousId: reportData.anonymousId,
        data: reportData,
        checksum: req.body.checksum
      });

      // 6. 緊急度に応じた通知
      await this.complianceService.notifyHandlers(report);

      // 7. 成功応答
      res.status(200).json({
        success: true,
        caseNumber,
        acknowledgementId: crypto.randomUUID(),
        receivedAt: new Date().toISOString(),
        message: 'Report received and processing started',
        estimatedResponseTime: this.getEstimatedResponseTime(report.severity)
      });

      // 8. 監査ログ記録（非同期）
      this.auditLog(requestId, 'REPORT_RECEIVED', report);

    } catch (error) {
      // エラーハンドリング
      console.error(`[${requestId}] Error:`, error);

      res.status(this.getErrorStatusCode(error)).json({
        success: false,
        error: {
          code: error.code || 'INTERNAL_ERROR',
          message: error.message || 'An unexpected error occurred',
          details: process.env.NODE_ENV === 'development' ? error.stack : undefined
        },
        requestId,
        timestamp: new Date().toISOString()
      });

      // エラーログ記録
      this.errorLog(requestId, error);
    }
  }

  private getEstimatedResponseTime(severity: string) {
    switch (severity) {
      case 'critical':
        return { value: 1, unit: 'hours' };
      case 'high':
        return { value: 24, unit: 'hours' };
      case 'medium':
        return { value: 3, unit: 'days' };
      default:
        return { value: 7, unit: 'days' };
    }
  }
}
```

### 4.2 ステータス更新Webhook

#### エンドポイント: VoiceDriveが指定するURL

**医療システム → VoiceDrive への通知**

```typescript
interface StatusUpdateWebhook {
  headers: {
    'Content-Type': 'application/json';
    'X-Webhook-Secret': string;  // 事前共有の秘密鍵
    'X-Case-Number': string;
    'X-Timestamp': string;
  };

  body: {
    reportId: string;           // VoiceDriveのレポートID
    caseNumber: string;         // 医療システムのケース番号
    anonymousId: string;        // 匿名ID

    status: {
      current: string;
      previous: string;
      changedAt: string;
      changedBy: {
        role: string;
        department: string;
      };
    };

    message?: string;           // 通報者への通知メッセージ

    investigation?: {
      assigned: boolean;
      investigator: {
        role: string;
        department: string;
      };
      estimatedCompletion?: string;
    };

    requiresAdditionalInfo?: {
      needed: boolean;
      type: string;
      deadline?: string;
    };
  };
}
```

### 4.3 進捗確認API

#### エンドポイント: `GET /api/v3/compliance/status/{anonymousId}`

**リクエスト：**
```typescript
interface StatusRequest {
  headers: {
    'Authorization': `Bearer ${token}`;
  };
  params: {
    anonymousId: string;
  };
}
```

**レスポンス：**
```typescript
interface StatusResponse {
  anonymousId: string;
  caseNumber: string;

  currentStatus: {
    code: string;
    label: string;
    description: string;
    since: string;
  };

  history: Array<{
    status: string;
    timestamp: string;
    note?: string;
  }>;

  estimatedCompletion?: string;

  actions: {
    canProvideAdditionalInfo: boolean;
    canWithdraw: boolean;
    canViewDetails: boolean;
  };

  nextSteps?: string;
}
```

---

## 5. セキュリティ実装要件

### 5.1 暗号化実装

```typescript
// src/services/CryptoService.ts
import crypto from 'crypto';

export class CryptoService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 16;
  private readonly tagLength = 16;
  private readonly saltLength = 64;

  /**
   * データの暗号化
   */
  async encrypt(data: string | Buffer): Promise<EncryptedData> {
    // 暗号化キーの取得（HSM対応）
    const key = await this.getEncryptionKey();

    // IV（初期化ベクトル）の生成
    const iv = crypto.randomBytes(this.ivLength);

    // 暗号化
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    // 認証タグの取得
    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      keyId: await this.getCurrentKeyId()
    };
  }

  /**
   * データの復号化
   */
  async decrypt(encryptedData: EncryptedData): Promise<string> {
    // 暗号化キーの取得
    const key = await this.getEncryptionKey(encryptedData.keyId);

    // 復号化の準備
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      Buffer.from(encryptedData.iv, 'hex')
    );

    // 認証タグの設定
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    // 復号化
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  /**
   * チェックサムの生成と検証
   */
  generateChecksum(data: any): string {
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }

  verifyChecksum(data: any, checksum: string): boolean {
    return this.generateChecksum(data) === checksum;
  }

  /**
   * 暗号鍵の管理（HSM対応）
   */
  private async getEncryptionKey(keyId?: string): Promise<Buffer> {
    // 本番環境ではHSM（Hardware Security Module）から取得
    if (process.env.USE_HSM === 'true') {
      return await this.getKeyFromHSM(keyId);
    }

    // 開発環境では環境変数から取得
    const key = process.env.ENCRYPTION_KEY;
    if (!key) {
      throw new Error('Encryption key not configured');
    }

    return Buffer.from(key, 'hex');
  }
}
```

### 5.2 認証・認可実装

```typescript
// src/middleware/AuthMiddleware.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

export class AuthMiddleware {
  /**
   * JWT認証ミドルウェア
   */
  async authenticate(req: Request, res: Response, next: NextFunction) {
    try {
      const token = this.extractToken(req);

      if (!token) {
        return res.status(401).json({
          error: 'Authentication required'
        });
      }

      // トークン検証
      const payload = await this.verifyToken(token);

      // ユーザー情報の取得
      req.user = await this.getUserFromPayload(payload);

      // 監査ログ
      await this.auditAccess(req.user, req);

      next();

    } catch (error) {
      res.status(401).json({
        error: 'Invalid or expired token'
      });
    }
  }

  /**
   * 権限チェックミドルウェア
   */
  authorize(requiredRoles: string[]) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const user = req.user;

      if (!user) {
        return res.status(401).json({
          error: 'Authentication required'
        });
      }

      // 権限チェック
      const hasPermission = requiredRoles.some(role =>
        user.roles.includes(role)
      );

      if (!hasPermission) {
        await this.auditUnauthorizedAccess(user, req);

        return res.status(403).json({
          error: 'Insufficient permissions'
        });
      }

      next();
    };
  }

  /**
   * レート制限ミドルウェア
   */
  rateLimit(maxRequests: number = 100, windowMs: number = 60000) {
    const requests = new Map();

    return (req: Request, res: Response, next: NextFunction) => {
      const key = this.getRateLimitKey(req);
      const now = Date.now();

      // 古いエントリーの削除
      const cutoff = now - windowMs;
      const timestamps = requests.get(key) || [];
      const validTimestamps = timestamps.filter(t => t > cutoff);

      if (validTimestamps.length >= maxRequests) {
        return res.status(429).json({
          error: 'Too many requests',
          retryAfter: Math.ceil(windowMs / 1000)
        });
      }

      validTimestamps.push(now);
      requests.set(key, validTimestamps);

      next();
    };
  }
}
```

### 5.3 監査ログ実装

```typescript
// src/services/AuditService.ts
export class AuditService {
  /**
   * 監査ログの記録（改ざん防止）
   */
  async logAction(params: AuditLogParams): Promise<void> {
    // 前のログのハッシュ値を取得
    const previousLog = await this.getLastLog();
    const previousHash = previousLog ? previousLog.currentHash : '0';

    // ログデータの構築
    const logData = {
      timestamp: new Date().toISOString(),
      userId: params.userId,
      userName: params.userName,
      userRole: params.userRole,
      action: params.action,
      reportId: params.reportId,
      details: params.details,
      ipAddress: params.ipAddress,
      userAgent: params.userAgent,
      sessionId: params.sessionId,
      previousHash
    };

    // 現在のログのハッシュ値を計算（改ざん防止）
    const currentHash = this.calculateHash(logData);

    // データベースに保存
    await this.db.auditLogs.create({
      data: {
        ...logData,
        currentHash
      }
    });

    // 重要なアクションは即座にアーカイブ
    if (this.isCriticalAction(params.action)) {
      await this.archiveToSecureStorage(logData);
    }
  }

  /**
   * ハッシュ値の計算（SHA-256）
   */
  private calculateHash(data: any): string {
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }

  /**
   * ログの整合性検証
   */
  async verifyLogIntegrity(fromDate: Date, toDate: Date): Promise<boolean> {
    const logs = await this.db.auditLogs.findMany({
      where: {
        timestamp: {
          gte: fromDate,
          lte: toDate
        }
      },
      orderBy: {
        id: 'asc'
      }
    });

    let previousHash = '0';

    for (const log of logs) {
      // ハッシュチェーンの検証
      if (log.previousHash !== previousHash) {
        console.error(`Chain broken at log ${log.id}`);
        return false;
      }

      // ハッシュ値の再計算と検証
      const recalculatedHash = this.calculateHash({
        ...log,
        currentHash: undefined
      });

      if (recalculatedHash !== log.currentHash) {
        console.error(`Hash mismatch at log ${log.id}`);
        return false;
      }

      previousHash = log.currentHash;
    }

    return true;
  }
}
```

---

## 6. 実装手順

### 6.1 Phase 1（必須機能）- 10営業日

#### Week 1（5営業日）

**Day 1-2: 環境構築とデータベース設計**
- [ ] 開発環境のセットアップ
- [ ] データベーステーブル作成
- [ ] 暗号化キーの生成と設定

**Day 3-5: API基盤実装**
- [ ] 通報受信APIの実装
- [ ] 認証・認可ミドルウェア
- [ ] 暗号化サービス

#### Week 2（5営業日）

**Day 6-7: ビジネスロジック実装**
- [ ] ケース番号生成ロジック
- [ ] 緊急度判定アルゴリズム
- [ ] 自動通知システム

**Day 8-10: テストと修正**
- [ ] 単体テスト作成
- [ ] 統合テスト実施
- [ ] セキュリティテスト

### 6.2 Phase 2（拡張機能）- 10営業日

**Week 3: 調査管理機能**
- [ ] 調査フロー実装
- [ ] 委員会連携機能
- [ ] 進捗管理ダッシュボード

**Week 4: UI実装とテスト**
- [ ] 管理画面の実装
- [ ] レポート機能
- [ ] 総合テスト

---

## 7. テスト要件

### 7.1 テストケース

```typescript
// test/compliance.spec.ts
describe('Compliance System Tests', () => {
  describe('API Tests', () => {
    it('should receive encrypted report successfully');
    it('should reject invalid checksum');
    it('should handle duplicate submissions');
    it('should notify urgent cases immediately');
  });

  describe('Security Tests', () => {
    it('should encrypt sensitive data');
    it('should verify JWT tokens');
    it('should enforce rate limiting');
    it('should log all access attempts');
  });

  describe('Business Logic Tests', () => {
    it('should generate unique case numbers');
    it('should classify severity correctly');
    it('should escalate critical cases');
    it('should maintain audit trail');
  });

  describe('Integration Tests', () => {
    it('should complete end-to-end flow');
    it('should handle concurrent requests');
    it('should recover from failures');
    it('should maintain data consistency');
  });
});
```

### 7.2 パフォーマンステスト

```yaml
負荷テストシナリオ:
  通常負荷:
    - 同時接続数: 100
    - リクエスト/秒: 10
    - 持続時間: 30分
    - 成功率目標: 99.9%

  ピーク負荷:
    - 同時接続数: 1000
    - リクエスト/秒: 100
    - 持続時間: 5分
    - 成功率目標: 99.5%

  ストレステスト:
    - 同時接続数: 5000
    - リクエスト/秒: 500
    - 持続時間: 1分
    - 劣化許容度: レスポンス時間3秒以内
```

---

## 8. 運用ドキュメント

### 8.1 システム管理者向けマニュアル

**必須記載項目：**

1. **初期設定手順**
   - 環境変数の設定
   - データベース初期化
   - 暗号鍵の生成と管理
   - 管理者アカウント作成

2. **日常運用**
   - 新規通報の確認
   - 担当者割り当て
   - エスカレーション判断基準
   - ステータス更新手順

3. **トラブルシューティング**
   - エラーログの確認方法
   - 一般的な問題と対処法
   - エスカレーション先

### 8.2 調査担当者向けマニュアル

1. **調査開始手順**
2. **証拠収集ガイドライン**
3. **ヒアリング実施要領**
4. **報告書作成基準**

---

## 9. 納品物一覧

### 9.1 必須納品物

- [ ] ソースコード一式
- [ ] データベース定義（DDL）
- [ ] API仕様書
- [ ] 運用マニュアル
- [ ] テスト結果報告書
- [ ] セキュリティ診断結果

### 9.2 ドキュメント

- [ ] システム設計書
- [ ] データフロー図
- [ ] ER図
- [ ] シーケンス図
- [ ] 運用フロー図

---

## 10. 受入条件

### 10.1 機能要件の充足

- 全必須機能の実装完了
- 小原病院規定への準拠
- VoiceDriveとの連携確認

### 10.2 非機能要件の達成

- 応答時間: 200ms以内（99%tile）
- 可用性: 99.9%以上
- セキュリティ: 全項目合格

### 10.3 テスト合格

- 単体テスト: カバレッジ80%以上
- 統合テスト: 全シナリオ成功
- セキュリティテスト: 脆弱性なし
- 負荷テスト: 基準値達成

---

## 11. サポート体制

### 11.1 保守サポート

- **期間**: 納品後1年間
- **対応時間**: 平日9:00-18:00
- **SLA**:
  - Critical: 1時間以内対応開始
  - High: 4時間以内対応開始
  - Medium/Low: 翌営業日対応

### 11.2 問い合わせ先

**技術的問い合わせ:**
- Email: tech-support@voicedrive.jp
- Slack: #compliance-system-support

**運用相談:**
- Email: operation@voicedrive.jp
- 電話: 03-XXXX-XXXX（緊急時のみ）

---

## 12. 注意事項

1. **法的要件の遵守**
   - 公益通報者保護法
   - 個人情報保護法
   - 医療法
   - 労働基準法

2. **セキュリティ**
   - 通報者情報は最高レベルの機密として扱う
   - アクセスログは改ざん防止措置必須
   - 暗号鍵は定期的にローテーション

3. **運用**
   - 24時間365日の可用性を確保
   - 定期的なバックアップ実施
   - 監査証跡の長期保管（最低5年）

---

## 承認欄

**依頼側（VoiceDriveチーム）:**

責任者: _____________________ 日付: _____________________

**受託側（医療職員管理システムチーム）:**

責任者: _____________________ 日付: _____________________

---

**本依頼書に関する質問・確認事項は、実装開始前に必ず解決してください。**

**文書管理番号**: MED-COMP-REQ-001
**最終更新日**: 2025年9月24日
**次回レビュー日**: 2025年10月1日